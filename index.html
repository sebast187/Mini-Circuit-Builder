<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Mini Circuit Builder V6.1 (MNA Build Debug)</title>
    <style>
        :root {
            --sim-bg-color: #f0f4f8; 
            --sim-panel-bg: #ffffff; 
            --sim-toolbar-bg: #e9edf1;
            --sim-accent-color: #ff6b6b; 
            --sim-highlight-color: #4ecdc4; 
            --sim-interactive-color: #45a0fc; 
            --sim-text-color: #2c3e50; 
            --sim-text-muted-color: #7f8c8d; 
            --sim-border-color: #ccd1d9;
            --wire-color: #3498db; 
            --wire-pending-color: #9b59b6; 
            --component-stroke-color: #34495e;
            --terminal-color: #e74c3c; 
            --terminal-hover-color: #f1c40f; 
            --electron-color: #f39c12; 
            --node-color: #8e44ad; 
            --node-hover-color: #c0392b; 
            --meter-case-color: #7f8c8d; 
            --meter-screen-color: #ecf0f1; 
        }

        body { 
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background-color: var(--sim-bg-color);
            color: var(--sim-text-color);
            margin: 0;
            padding: 0;
            display: flex;
            flex-direction: column;
            align-items: center;
            min-height: 100vh;
            overflow-x: hidden;
        }

        .main-container { 
            display: flex;
            width: 95%;
            max-width: 1600px; 
            margin-top: 20px;
            gap: 20px;
        }

        .toolbar { 
            background-color: var(--sim-toolbar-bg);
            padding: 15px;
            border-radius: 8px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
            display: flex;
            flex-direction: column;
            gap: 10px;
            align-items: center;
            height: fit-content;
            min-width: 130px; 
        }

        .toolbar button { 
            background-color: var(--sim-interactive-color);
            color: white;
            border: none;
            padding: 10px 12px;
            border-radius: 6px;
            cursor: pointer;
            font-size: 0.9em;
            transition: background-color 0.2s ease;
            width: 100%;
            text-align: center;
        }
        .toolbar button.active, .toolbar button:hover { 
            background-color: var(--sim-highlight-color);
        }
        .toolbar button.tool-active {  
             background-color: var(--sim-accent-color);
             color: white;
        }
        .toolbar h3 { 
            margin: 10px 0 5px 0;
            font-size: 1.1em;
            color: var(--sim-text-color);
        }
        .toolbar h3:first-child { margin-top: 0;}

        .canvas-container { 
            flex-grow: 1;
            display: flex;
            flex-direction: column;
            align-items: center;
        }

        #circuitCanvas { 
            border: 2px solid var(--sim-border-color);
            background-color: var(--sim-panel-bg);
            border-radius: 8px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.05);
            cursor: crosshair; 
        }
        #circuitCanvas.dragging { cursor: grabbing; }
        #circuitCanvas.selectable { cursor: pointer; }


        .properties-panel, .simulation-output { 
            background-color: var(--sim-panel-bg);
            padding: 15px;
            border-radius: 8px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
            width: 300px; 
            min-width: 300px; 
            height: fit-content;
        }
        .properties-panel h3, .simulation-output h3 { 
            margin: 0 0 15px 0;
            font-size: 1.1em;
            color: var(--sim-text-color);
            border-bottom: 1px solid var(--sim-border-color);
            padding-bottom: 8px;
        }
        .properties-panel label { 
            display: block;
            margin: 10px 0 5px 0;
            font-size: 0.9em;
            color: var(--sim-text-muted-color);
        }
        .properties-panel input[type="number"],
        .properties-panel input[type="text"] { 
            width: calc(100% - 22px); 
            padding: 8px 10px;
            border: 1px solid var(--sim-border-color);
            border-radius: 4px;
            font-size: 0.9em;
            background-color: var(--sim-bg-color);
            color: var(--sim-text-color);
            box-sizing: border-box;
        }
        .properties-panel p { 
            font-size: 0.9em;
            color: var(--sim-text-muted-color);
        }
         .properties-panel button { 
            background-color: var(--sim-interactive-color);
            color: white;
            border: none;
            padding: 8px 10px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 0.9em;
            margin-top: 10px;
            width: 100%;
        }
        .properties-panel button.toggle-active { 
            background-color: var(--sim-highlight-color);
        }
        .properties-panel button:hover { 
            background-color: var(--sim-highlight-color); opacity: 0.8;
        }

        .simulation-output p { 
            font-size: 0.9em;
            margin: 8px 0;
        }
        .simulation-output code { 
            font-family: 'Courier New', Courier, monospace;
            background-color: var(--sim-toolbar-bg);
            padding: 2px 5px;
            border-radius: 3px;
            color: var(--sim-accent-color);
        }
        .simulation-output details summary {
            cursor: pointer;
            color: var(--sim-interactive-color);
        }
        .simulation-output details pre {
            background-color: var(--sim-toolbar-bg);
            padding: 10px;
            border-radius: 4px;
            font-size: 0.8em;
            overflow-x: auto;
            color: var(--sim-text-muted-color);
        }


        .info-bar { 
            margin-top: 10px;
            padding: 10px;
            background-color: var(--sim-toolbar-bg);
            border-radius: 6px;
            font-size: 0.9em;
            text-align: center;
            width: calc(100% - 20px); 
        }
    </style>
</head>
<body>
    <div class="main-container">
        <div class="toolbar">
            <h3>Tools</h3>
            <button id="tool-select" title="Select/Move Tool (V)">Select (V)</button>
            <button id="tool-wire" title="Wire Tool (W)">Wire (W)</button>
            <button id="tool-node" title="Place Node/Junction (J)">Node (J)</button>
            <h3>Passive Components</h3>
            <button id="tool-resistor" data-component="Resistor">Resistor</button>
            <button id="tool-capacitor" data-component="Capacitor">Capacitor</button>
            <button id="tool-switch" data-component="Switch">Switch</button>
            <h3>Active/Sources</h3>
            <button id="tool-vsource" data-component="VSource">Voltage Src</button>
            <button id="tool-led" data-component="LED">LED</button>
            <button id="tool-gnd" data-component="Ground">Ground</button>
            <h3>Meters</h3>
            <button id="tool-ammeter" data-component="Ammeter">Ammeter</button>
            <button id="tool-voltmeter" data-component="Voltmeter">Voltmeter</button>
             <h3>Actions</h3>
            <button id="action-delete" title="Delete Selected (Del/Backspace)">Delete</button>
            <button id="action-clear" title="Clear Canvas">Clear All</button>
        </div>

        <div class="canvas-container">
            <canvas id="circuitCanvas" width="800" height="600"></canvas>
            <div class="info-bar" id="infoBar">Select a tool or component to start.</div>
        </div>

        <div class="side-panel">
            <div class="properties-panel" id="propertiesPanel">
                <h3>Properties</h3>
                <p id="noSelectionText">No item selected.</p>
                <div id="selectedItemProps" style="display:none;">
                    <label for="prop-id">ID:</label>
                    <input type="text" id="prop-id" readonly>
                    
                    <div id="componentSpecificProps">
                        <label for="prop-value">Value:</label>
                        <input type="number" id="prop-value" step="any">
                        <span id="prop-unit"></span>
                        <button id="prop-rotate">Rotate (R)</button>
                        <div id="switchSpecificProps" style="display:none;">
                             <button id="prop-switch-toggle">Toggle Switch</button>
                        </div>
                    </div>

                    <div id="nodeSpecificProps" style.display="none;">
                        <p>This is a connection node.</p>
                    </div>
                    <div id="meterSpecificProps" style.display="none;">
                        <p>Reading: <code id="meter-reading">N/A</code></p>
                    </div>
                </div>
            </div>
            <div class="simulation-output" style="margin-top:20px;">
                <h3>DC MNA Simulation</h3>
                <p>Status: <code id="sim-status">Build a circuit.</code></p>
                <div id="node-voltages-display"></div>
                <div id="component-currents-voltages"></div>
                 <details>
                    <summary>MNA System (Debug)</summary>
                    <pre id="mna-debug-g"></pre>
                    <pre id="mna-debug-z"></pre>
                    <pre id="mna-debug-x"></pre>
                </details>
            </div>
        </div>
    </div>

    <script>
        // Minimal Matrix Math (for Gaussian Elimination)
        function solveLinearSystem(A_orig, b_orig) {
            const n = A_orig.length;
            const A = JSON.parse(JSON.stringify(A_orig)); // Deep copy
            const b = JSON.parse(JSON.stringify(b_orig)); // Deep copy

            for (let i = 0; i < n; i++) {
                let maxEl = Math.abs(A[i][i]);
                let maxRow = i;
                for (let k = i + 1; k < n; k++) {
                    if (Math.abs(A[k][i]) > maxEl) {
                        maxEl = Math.abs(A[k][i]);
                        maxRow = k;
                    }
                }

                for (let k = i; k < n; k++) { // Swap rows in A
                    [A[maxRow][k], A[i][k]] = [A[i][k], A[maxRow][k]];
                }
                [b[maxRow], b[i]] = [b[i], b[maxRow]]; // Swap rows in b

                if (A[i][i] === 0) {
                    console.warn("Singular matrix detected during elimination (A[i][i] is 0 at step " + i + ")");
                    return null; // Pivoting failed or singular matrix
                }

                for (let k = i + 1; k < n; k++) {
                    const c = -A[k][i] / A[i][i];
                    for (let j = i; j < n; j++) {
                        if (i === j) A[k][j] = 0;
                        else A[k][j] += c * A[i][j];
                    }
                    b[k] += c * b[i];
                }
            }

            const x = new Array(n);
            for (let i = n - 1; i > -1; i--) {
                 if (A[i][i] === 0) {
                    console.warn("Singular matrix detected during back-substitution (A[i][i] is 0 at step " + i + ")");
                    return null; 
                }
                x[i] = b[i] / A[i][i];
                for (let k = i - 1; k > -1; k--) {
                    b[k] -= A[k][i] * x[i];
                }
            }
            return x;
        }


        const canvas = document.getElementById('circuitCanvas');
        const ctx = canvas.getContext('2d');
        const infoBar = document.getElementById('infoBar');

        // --- State Variables ---
        let components = [];
        let wires = [];
        let nodes = []; 
        let nextItemId = 1; 
        let selectedTool = 'select'; 
        let selectedItem = null; 
        let hoveredConnectable = null; 
        let wiringState = { active: false, startItem: null, points: [], currentEndPoint: {x:0, y:0} };
        let draggingItem = null; 
        let dragStartOffset = { x: 0, y: 0};
        const gridSize = 20;
        const terminalRadius = 6;
        const nodeRadius = 7;
        const GROUND_NODE_ID = 'N0_GROUND'; // Made more unique

        let electrons = []; 
        const electronSpeedFactor = 0.5;

        // --- Component Definitions & Drawing --- 
        const componentSpecs = { /* ... (same as V5.1) ... */ 
            VSource: { width: 60, height: 60, color: '#f1c40f', terminals: [{ x: 0, y: -30, id: 'p' }, { x: 0, y: 30, id: 'n' }], defaultValue: 9, unit: 'V', label: 'V' },
            Resistor: { width: 80, height: 30, color: '#bdc3c7', terminals: [{ x: -40, y: 0, id: 't1' }, { x: 40, y: 0, id: 't2' }], defaultValue: 100, unit: 'Ω', label: 'R' },
            LED: { width: 50, height: 50, color: '#e74c3c', terminals: [{ x: -25, y: 0, id: 'a' }, { x: 25, y: 0, id: 'k' }], defaultValue: 2, unit: 'Vf', label: 'LED' },
            Capacitor: { width: 50, height: 50, color: '#3498db', terminals: [{x: -25, y: 0, id: 't1'}, {x: 25, y: 0, id: 't2'}], defaultValue: 100e-6, unit: 'F', label: 'C' },
            Switch: {width: 60, height: 30, color: '#7f8c8d', terminals: [{x: -30, y: 0, id: 't1'}, {x: 30, y: 0, id: 't2'}], defaultValue: 0, unit: '', label: 'SW', 
                     defaultState: { isOpen: true } }, 
            Ammeter: { width: 60, height: 60, color: '#f39c12', terminals: [{x: -30, y: 0, id: 'in'}, {x: 30, y: 0, id: 'out'}], defaultValue: 0, unit: 'A', label: 'A',
                       defaultState: { reading: 0 }},
            Voltmeter: { width: 60, height: 60, color: '#9b59b6', terminals: [{x: 0, y: -30, id: 'p'}, {x: 0, y: 30, id: 'n'}], defaultValue: 0, unit: 'V', label: 'V',
                         defaultState: { reading: 0 }}, 
            Ground: { width: 40, height: 40, color: '#2ecc71', terminals: [{ x: 0, y: -20, id: 'gnd' }], defaultValue: 0, unit: '', label: 'GND' }
        };
        
        function drawVSource(comp, spec) { /* ... (same as V5.1) ... */ 
            ctx.strokeStyle = 'var(--component-stroke-color)'; ctx.lineWidth = 2;
            ctx.fillStyle = spec.color; 
            ctx.beginPath();
            ctx.arc(0, 0, spec.width / 2 * 0.8, 0, Math.PI * 2);
            ctx.fill(); ctx.stroke();
            ctx.fillStyle = 'var(--component-stroke-color)'; ctx.font = '16px Arial'; ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillText('+', 0, -spec.height / 4.5);
            ctx.fillText('-', 0, spec.height / 4.5);
            ctx.save();
            ctx.resetTransform(); 
            ctx.translate(comp.x, comp.y); 
            ctx.fillStyle = 'var(--component-stroke-color)'; ctx.font = '12px Arial'; ctx.textAlign = 'center';
            ctx.fillText(`${formatValue(comp.value, spec.unit)}${spec.unit}`, 0, spec.height/2 + 15);
            ctx.restore(); 
        }
        function drawResistor(comp, spec) { /* ... (same as V5.1) ... */
            ctx.strokeStyle = 'var(--component-stroke-color)'; ctx.lineWidth = 2;
            ctx.fillStyle = spec.color;
            ctx.fillRect(-spec.width/2 + 10, -spec.height/2, spec.width - 20, spec.height);
            ctx.strokeRect(-spec.width/2 + 10, -spec.height/2, spec.width - 20, spec.height);
            ctx.beginPath(); 
            ctx.moveTo(-spec.width/2, 0); ctx.lineTo(-spec.width/2+10, 0);
            ctx.moveTo(spec.width/2-10, 0); ctx.lineTo(spec.width/2, 0);
            ctx.stroke();
            
            ctx.save(); ctx.resetTransform(); ctx.translate(comp.x, comp.y);
            ctx.fillStyle = 'var(--component-stroke-color)'; ctx.font = '12px Arial'; ctx.textAlign = 'center';
            ctx.fillText(`${formatValue(comp.value, spec.unit)}${spec.unit}`, 0, spec.height/2 + 15);
            if (comp.voltageDrop && Math.abs(comp.voltageDrop) > 0.001) {
                 ctx.fillStyle = 'var(--sim-interactive-color)';
                 const angle = comp.rotation % 180;
                 const yOffset = (angle === 0) ? -spec.height/2 - 8 : spec.width/2 + 8;
                 const xOffset = (angle === 90) ? -spec.height/2 -15 : 0;
                 ctx.fillText(`${comp.voltageDrop.toFixed(2)}V`, xOffset, yOffset);
            }
            ctx.restore();
        }
        function drawLED(comp, spec) { /* ... (same as V5.1) ... */
            ctx.strokeStyle = 'var(--component-stroke-color)'; ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.moveTo(-spec.width/2 + 5, -spec.height/3); 
            ctx.lineTo(-spec.width/2 + 5, spec.height/3);
            ctx.lineTo(0, 0); 
            ctx.closePath();
            
            let ledColor = 'rgba(100,100,100,0.5)'; 
            if (comp.brightness > 0) ledColor = `rgba(255, 0, 0, ${0.2 + comp.brightness * 0.8})`;
            ctx.fillStyle = ledColor;
            ctx.fill(); ctx.stroke();
            ctx.beginPath();
            ctx.moveTo(spec.width/2 - 10, -spec.height/3);
            ctx.lineTo(spec.width/2 - 10, spec.height/3);
            ctx.stroke();
            ctx.beginPath();
            ctx.moveTo(-spec.width/2, 0); ctx.lineTo(-spec.width/2+5, 0);
            ctx.moveTo(spec.width/2-10, 0); ctx.lineTo(spec.width/2, 0);
            ctx.stroke();

            ctx.save(); ctx.resetTransform(); ctx.translate(comp.x, comp.y);
            ctx.fillStyle = 'var(--component-stroke-color)'; ctx.font = '12px Arial'; ctx.textAlign = 'center';
            ctx.fillText(`${spec.label} (Vf:${comp.value}V)`, 0, spec.height/2 + 15);
             if (comp.voltageDrop && Math.abs(comp.voltageDrop) > 0.001) {
                 ctx.fillStyle = 'var(--sim-interactive-color)';
                 const angle = comp.rotation % 180;
                 const yOffset = (angle === 0) ? -spec.height/2 - 8 : spec.width/2 + 8;
                 const xOffset = (angle === 90) ? -spec.height/2 -15 : 0;
                 ctx.fillText(`${comp.voltageDrop.toFixed(2)}V`, xOffset, yOffset);
            }
            ctx.restore();
        }
        function drawCapacitor(comp, spec) { /* ... (same as V5.1) ... */
            ctx.strokeStyle = 'var(--component-stroke-color)'; ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.moveTo(-spec.width/2, 0); ctx.lineTo(-spec.width/2 + 15, 0); 
            ctx.moveTo(spec.width/2, 0);  ctx.lineTo(spec.width/2 - 15, 0);   
            ctx.stroke();
            ctx.beginPath();
            ctx.moveTo(-spec.width/2 + 15, -spec.height/2 + 5); ctx.lineTo(-spec.width/2 + 15, spec.height/2 - 5); 
            ctx.moveTo(spec.width/2 - 15, -spec.height/2 + 5);  ctx.lineTo(spec.width/2 - 15, spec.height/2 - 5);   
            ctx.stroke();
            
            ctx.save(); ctx.resetTransform(); ctx.translate(comp.x, comp.y);
            ctx.fillStyle = 'var(--component-stroke-color)'; ctx.font = '12px Arial'; ctx.textAlign = 'center';
            ctx.fillText(`${formatValue(comp.value, spec.unit)}${spec.unit}`, 0, spec.height/2 + 15);
            if (comp.voltageDrop && Math.abs(comp.voltageDrop) > 0.001) { 
                 ctx.fillStyle = 'var(--sim-interactive-color)';
                 const angle = comp.rotation % 180;
                 const yOffset = (angle === 0) ? -spec.height/2 - 8 : spec.width/2 + 8;
                 const xOffset = (angle === 90) ? -spec.height/2 -15 : 0;
                 ctx.fillText(`${comp.voltageDrop.toFixed(2)}V`, xOffset, yOffset);
            }
            ctx.restore();
        }
        function drawSwitch(comp, spec) { /* ... (same as V5.1) ... */
            ctx.strokeStyle = 'var(--component-stroke-color)'; ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.arc(-spec.width/2 + 5, 0, 3, 0, Math.PI*2); 
            ctx.arc(spec.width/2 - 5, 0, 3, 0, Math.PI*2); 
            ctx.fillStyle = 'var(--component-stroke-color)'; 
            ctx.fill();
            ctx.beginPath(); 
            ctx.moveTo(-spec.width/2, 0); ctx.lineTo(-spec.width/2 + 5, 0);
            ctx.moveTo(spec.width/2, 0); ctx.lineTo(spec.width/2 - 5, 0);
            ctx.stroke();
            ctx.beginPath();
            ctx.moveTo(-spec.width/2 + 5, 0); 
            if (comp.state.isOpen) {
                ctx.lineTo(0, -spec.height/2 + 5); 
            } else {
                ctx.lineTo(spec.width/2 - 5, 0); 
            }
            ctx.stroke();
            
            ctx.save(); ctx.resetTransform(); ctx.translate(comp.x, comp.y);
            ctx.fillStyle = 'var(--component-stroke-color)'; ctx.font = '12px Arial'; ctx.textAlign = 'center';
            ctx.fillText(comp.state.isOpen ? 'Open' : 'Closed', 0, spec.height/2 + 15);
            ctx.restore();
        }
        function drawAmmeter(comp, spec) { /* ... (same as V5.1) ... */
            ctx.strokeStyle = 'var(--component-stroke-color)'; ctx.lineWidth = 2;
            ctx.fillStyle = 'var(--meter-case-color)';
            ctx.beginPath();
            ctx.arc(0,0, spec.width/2, 0, Math.PI * 2); 
            ctx.fill(); ctx.stroke();
            
            ctx.fillStyle = 'var(--meter-screen-color)';
            ctx.fillRect(-spec.width/3, -spec.height/4, spec.width*2/3, spec.height/2);
            ctx.strokeRect(-spec.width/3, -spec.height/4, spec.width*2/3, spec.height/2);

            ctx.fillStyle = 'var(--component-stroke-color)'; ctx.font = 'bold 14px Arial'; ctx.textAlign = 'center'; ctx.textBaseline = 'middle';
            ctx.fillText(spec.label, 0, 0); 
            
            ctx.save(); ctx.resetTransform(); ctx.translate(comp.x, comp.y); 
            ctx.fillStyle = 'var(--component-stroke-color)'; ctx.font = '10px Courier New'; ctx.textAlign = 'center';
            ctx.fillText(`${formatValue(comp.state.reading, spec.unit)}${spec.unit}`, 0, spec.height/2 + 12);
            ctx.restore();
        }
        function drawVoltmeter(comp, spec) { /* ... (same as V5.1) ... */
            ctx.strokeStyle = 'var(--component-stroke-color)'; ctx.lineWidth = 2;
            ctx.fillStyle = 'var(--meter-case-color)';
            ctx.beginPath();
            ctx.arc(0,0, spec.width/2, 0, Math.PI * 2);
            ctx.fill(); ctx.stroke();
            
            ctx.fillStyle = 'var(--meter-screen-color)';
            ctx.fillRect(-spec.width/3, -spec.height/4, spec.width*2/3, spec.height/2);
            ctx.strokeRect(-spec.width/3, -spec.height/4, spec.width*2/3, spec.height/2);

            ctx.fillStyle = 'var(--component-stroke-color)'; ctx.font = 'bold 14px Arial'; ctx.textAlign = 'center'; ctx.textBaseline = 'middle';
            ctx.fillText(spec.label, 0, 0); 
            
            ctx.save(); ctx.resetTransform(); ctx.translate(comp.x, comp.y);
            ctx.fillStyle = 'var(--component-stroke-color)'; ctx.font = '10px Courier New'; ctx.textAlign = 'center';
            ctx.fillText(`${formatValue(comp.state.reading, spec.unit)}${spec.unit}`, 0, spec.height/2 + 12);
            ctx.restore();
        }
        function drawGround(comp, spec) { /* ... (same as V5.1) ... */
            ctx.strokeStyle = 'var(--component-stroke-color)'; ctx.lineWidth = 2;
            ctx.fillStyle = spec.color;
            ctx.beginPath();
            ctx.moveTo(0, -spec.height/2); 
            ctx.lineTo(0, 0); 
            ctx.moveTo(-spec.width/2 + 5, 0); ctx.lineTo(spec.width/2 - 5, 0); 
            ctx.moveTo(-spec.width/2 + 10, spec.height/4); ctx.lineTo(spec.width/2 - 10, spec.height/4);
            ctx.moveTo(-spec.width/2 + 15, spec.height/2); ctx.lineTo(spec.width/2 - 15, spec.height/2); 
            ctx.stroke();
            
            ctx.save(); ctx.resetTransform(); ctx.translate(comp.x, comp.y);
            ctx.fillStyle = 'var(--component-stroke-color)'; ctx.font = '12px Arial'; ctx.textAlign = 'center';
            ctx.fillText(spec.label, 0, spec.height/2 + 10);
            ctx.restore();
        }

        const drawFunctions = { 
            VSource: drawVSource, Resistor: drawResistor, LED: drawLED, Capacitor: drawCapacitor, 
            Switch: drawSwitch, Ammeter: drawAmmeter, Voltmeter: drawVoltmeter, Ground: drawGround 
        };

        function getAbsTerminalPos(component, terminalId) { /* ... (same as V5.1) ... */
            const termSpec = component.spec.terminals.find(t => t.id === terminalId);
            if (!termSpec) return { x: component.x, y: component.y }; 

            const angleRad = component.rotation * Math.PI / 180;
            const cosA = Math.cos(angleRad);
            const sinA = Math.sin(angleRad);

            const rotatedX = termSpec.x * cosA - termSpec.y * sinA;
            const rotatedY = termSpec.x * sinA + termSpec.y * cosA;

            return { x: component.x + rotatedX, y: component.y + rotatedY };
        }
        
        function drawComponent(comp) { /* ... (same as V5.1) ... */
            ctx.save();
            ctx.translate(comp.x, comp.y); 
            ctx.rotate(comp.rotation * Math.PI / 180); 

            if (drawFunctions[comp.type]) { 
                 drawFunctions[comp.type](comp, comp.spec); 
            } else {
                console.error("No draw function for component type:", comp.type);
            }
            
            comp.spec.terminals.forEach(term => {
                ctx.beginPath();
                ctx.arc(term.x, term.y, terminalRadius, 0, Math.PI * 2);
                const isHovered = hoveredConnectable && hoveredConnectable.type === 'terminal' && 
                                  hoveredConnectable.componentId === comp.id && hoveredConnectable.terminalId === term.id;
                ctx.fillStyle = isHovered ? 'var(--terminal-hover-color)' : 'var(--terminal-color)';
                ctx.fill();
            });
            ctx.restore(); 

            if (selectedItem && selectedItem.itemType === 'component' && selectedItem.id === comp.id) {
                ctx.strokeStyle = 'var(--sim-highlight-color)';
                ctx.lineWidth = 2;
                const w = comp.spec.width; const h = comp.spec.height;
                const angle = comp.rotation % 180; 
                const displayW = (angle === 0) ? w : h;
                const displayH = (angle === 0) ? h : w;
                ctx.strokeRect(comp.x - displayW/2 - 5, comp.y - displayH/2 - 5, displayW + 10, displayH + 10);
            }
        }
        function drawNode(node) { /* ... (same as V5.1) ... */
            ctx.beginPath();
            ctx.arc(node.x, node.y, nodeRadius, 0, Math.PI * 2);
            const isHovered = hoveredConnectable && hoveredConnectable.type === 'node' && hoveredConnectable.id === node.id;
            ctx.fillStyle = isHovered ? 'var(--node-hover-color)' : 'var(--node-color)';
            ctx.fill();
            if (selectedItem && selectedItem.itemType === 'node' && selectedItem.id === node.id) {
                ctx.strokeStyle = 'var(--sim-highlight-color)';
                ctx.lineWidth = 2;
                ctx.strokeRect(node.x - nodeRadius - 3, node.y - nodeRadius - 3, nodeRadius*2 + 6, nodeRadius*2 + 6);
            }
        }
        function drawWires() { /* ... (same as V5.1) ... */
            wires.forEach(wire => {
                if (wire.points.length < 2) return;
                ctx.beginPath();
                ctx.moveTo(wire.points[0].x, wire.points[0].y);
                for (let i = 1; i < wire.points.length; i++) {
                    ctx.lineTo(wire.points[i].x, wire.points[i].y);
                }
                ctx.strokeStyle = 'var(--wire-color)';
                ctx.lineWidth = 3;
                ctx.stroke();
            });

            if (wiringState.active && wiringState.points.length > 0) {
                ctx.beginPath();
                const lastPoint = wiringState.points[wiringState.points.length - 1];
                ctx.moveTo(lastPoint.x, lastPoint.y);
                ctx.lineTo(wiringState.currentEndPoint.x, wiringState.currentEndPoint.y);
                ctx.strokeStyle = 'var(--wire-pending-color)';
                ctx.lineWidth = 2;
                ctx.setLineDash([5, 5]);
                ctx.stroke();
                ctx.setLineDash([]);
            }
        }
        function drawElectrons() { /* ... (same as V5.1) ... */
            electrons.forEach(e => {
                ctx.beginPath();
                ctx.arc(e.x, e.y, 3, 0, Math.PI * 2);
                ctx.fillStyle = 'var(--electron-color)';
                ctx.fill();
            });
        }

        function redrawCanvas() { /* ... (same as V5.1) ... */
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            nodes.forEach(drawNode);
            components.forEach(drawComponent); 
            drawWires();
            drawElectrons();
        }

        // --- UI & Interaction ---
        function updateToolbarButtons() { /* ... (same as V5.1) ... */
            document.querySelectorAll('.toolbar button[data-component], #tool-select, #tool-wire, #tool-node').forEach(btn => {
                btn.classList.remove('tool-active');
                if ((btn.dataset.component && btn.dataset.component === selectedTool) || (btn.id === `tool-${selectedTool}`)) {
                    btn.classList.add('tool-active');
                }
            });
            let toolInfo = `Tool: ${selectedTool}.`;
            if (selectedTool === 'wire') toolInfo += " Click terminal/node or empty space for joints.";
            else if (componentSpecs[selectedTool] || selectedTool === 'Node') toolInfo += " Click canvas to place.";
            else toolInfo += " Click item to select/drag.";
            infoBar.textContent = toolInfo;
        }
        function setActiveTool(toolName) { /* ... (same as V5.1) ... */
            selectedTool = toolName;
            selectedItem = null; 
            updatePropertiesPanel();
            if (wiringState.active) { 
                wiringState.active = false;
                wiringState.points = [];
            }
            updateToolbarButtons();
        }

        document.getElementById('tool-select').addEventListener('click', () => setActiveTool('select'));
        document.getElementById('tool-wire').addEventListener('click', () => setActiveTool('wire'));
        document.getElementById('tool-node').addEventListener('click', () => setActiveTool('Node')); 
        document.querySelectorAll('.toolbar button[data-component]').forEach(btn => {
            btn.addEventListener('click', () => setActiveTool(btn.dataset.component));
        });
        document.getElementById('action-delete').addEventListener('click', deleteSelected);
        document.getElementById('action-clear').addEventListener('click', () => {
            components = []; wires = []; nodes = []; electrons = []; nextItemId = 1; 
            selectedItem = null; wiringState.active = false; wiringState.points = [];
            updatePropertiesPanel(); simulateCircuit(); redrawCanvas();
        });

        function getMousePos(evt, doSnap = true) { /* ... (same as V5.1) ... */
            const rect = canvas.getBoundingClientRect();
            const rawX = evt.clientX - rect.left;
            const rawY = evt.clientY - rect.top;
            if (doSnap) {
                return {
                    x: Math.round(rawX / gridSize) * gridSize,
                    y: Math.round(rawY / gridSize) * gridSize,
                    rawX: rawX, rawY: rawY
                };
            }
            return { x: rawX, y: rawY, rawX: rawX, rawY: rawY }; 
        }
        function getHoveredConnectable(rawX, rawY) { /* ... (same as V5.1) ... */
            for (const comp of components) { 
                for (const term of comp.spec.terminals) {
                    const absPos = getAbsTerminalPos(comp, term.id);
                    const dist = Math.sqrt((rawX - absPos.x)**2 + (rawY - absPos.y)**2);
                    if (dist < terminalRadius + 3) { 
                        return { type: 'terminal', componentId: comp.id, terminalId: term.id, absPos: absPos, item: comp };
                    }
                }
            }
            for (const node of nodes) {
                const dist = Math.sqrt((rawX - node.x)**2 + (rawY - node.y)**2);
                if (dist < nodeRadius + 3) {
                    return { type: 'node', id: node.id, absPos: {x: node.x, y: node.y}, item: node };
                }
            }
            return null;
        }
        
        function getClickedComponent(rawX, rawY) { /* ... (same as V5.1) ... */
             for (let i = components.length - 1; i >= 0; i--) {
                const comp = components[i];
                const angleRad = -comp.rotation * Math.PI / 180; 
                const cosA = Math.cos(angleRad);
                const sinA = Math.sin(angleRad);

                const localX = rawX - comp.x;
                const localY = rawY - comp.y;

                const unrotX = localX * cosA - localY * sinA;
                const unrotY = localX * sinA + localY * cosA;

                if (unrotX >= -comp.spec.width/2 && unrotX <= comp.spec.width/2 &&
                    unrotY >= -comp.spec.height/2 && unrotY <= comp.spec.height/2) {
                    return comp; 
                }
            }
            return null;
        }
        
        function getClickedItem(rawX, rawY) { /* ... (same as V5.1) ... */
            const comp = getClickedComponent(rawX, rawY);
            if (comp) return comp; 

            for (const nodeItem of nodes) {
                const dist = Math.sqrt((rawX - nodeItem.x)**2 + (rawY - nodeItem.y)**2);
                if (dist < nodeRadius + 3) {
                    return nodeItem; 
                }
            }
            return null;
        }


        canvas.addEventListener('mousemove', (evt) => { /* ... (same as V5.1) ... */
            const { rawX, rawY } = getMousePos(evt, false); 
            hoveredConnectable = getHoveredConnectable(rawX, rawY);
            
            canvas.classList.remove('selectable', 'dragging');
            if (selectedTool === 'select' && (getClickedItem(rawX, rawY) || hoveredConnectable)) {
                 canvas.classList.add('selectable');
            }
            if (draggingItem) {
                 canvas.classList.add('dragging');
            }

            if (wiringState.active) {
                wiringState.currentEndPoint = {x: rawX, y: rawY};
            } else if (draggingItem) {
                const mousePos = getMousePos(evt); 
                draggingItem.x = mousePos.x - dragStartOffset.x;
                draggingItem.y = mousePos.y - dragStartOffset.y;
                updateConnectedWires(draggingItem); 
            }
            redrawCanvas();
        });

        canvas.addEventListener('mousedown', (evt) => { /* ... (same as V5.1, direct references) ... */
            const { x, y, rawX, rawY } = getMousePos(evt); 
            const clickedConnectable = getHoveredConnectable(rawX, rawY);

            if (evt.button !== 0) return;

            if (selectedTool === 'wire') {
                if (!wiringState.active) { 
                    if (clickedConnectable) {
                        wiringState.active = true;
                        wiringState.startItem = clickedConnectable; 
                        wiringState.points = [clickedConnectable.absPos];
                        wiringState.currentEndPoint = {x: rawX, y: rawY};
                    }
                } else { 
                    if (clickedConnectable) { 
                        const startIsNode = wiringState.startItem.type === 'node';
                        const endIsNode = clickedConnectable.type === 'node';
                        
                        let startIdVal, endIdVal;
                        if (startIsNode) startIdVal = wiringState.startItem.id;
                        else startIdVal = wiringState.startItem.componentId + "_" + wiringState.startItem.terminalId;

                        if (endIsNode) endIdVal = clickedConnectable.id;
                        else endIdVal = clickedConnectable.componentId + "_" + clickedConnectable.terminalId;


                        if (startIdVal !== endIdVal) {
                            wiringState.points.push(clickedConnectable.absPos);
                            wires.push({
                                id: `w${nextItemId++}`,
                                from: JSON.parse(JSON.stringify(wiringState.startItem)), 
                                to: JSON.parse(JSON.stringify(clickedConnectable)),     
                                points: [...wiringState.points] 
                            });
                            wiringState.active = false; wiringState.points = [];
                            simulateCircuit();
                        } else { 
                           console.warn("Invalid wire end (cannot connect to self).");
                           wiringState.active = false; wiringState.points = []; 
                        }
                    } else { 
                        wiringState.points.push({x: x, y: y}); 
                        wiringState.currentEndPoint = {x: rawX, y: rawY};
                    }
                }
            } else if (selectedTool === 'Node') {
                const newNode = { 
                    id: `n${nextItemId++}`, 
                    itemType: 'node', 
                    x: x, y: y
                };
                nodes.push(newNode);
                selectedItem = newNode; 
                updatePropertiesPanel();
                setActiveTool('select'); 
            } else if (componentSpecs[selectedTool]) { 
                const spec = componentSpecs[selectedTool];
                const newComp = {
                    id: `${selectedTool.charAt(0)}${nextItemId++}`,
                    itemType: 'component', 
                    type: selectedTool,
                    x: x, y: y, 
                    rotation: 0,
                    value: spec.defaultValue,
                    spec: spec,
                    state: spec.defaultState ? JSON.parse(JSON.stringify(spec.defaultState)) : {}, 
                    brightness: 0, 
                    voltageDrop: 0 
                };
                components.push(newComp);
                selectedItem = newComp; 
                updatePropertiesPanel();
                setActiveTool('select'); 
            } else if (selectedTool === 'select') { 
                const itemUnderMouse = getClickedItem(rawX, rawY); // Returns direct reference
                
                if (itemUnderMouse) {
                    selectedItem = itemUnderMouse; 
                    draggingItem = selectedItem;   
                    
                    if (draggingItem) { 
                        dragStartOffset.x = x - draggingItem.x; 
                        dragStartOffset.y = y - draggingItem.y;
                        canvas.classList.add('dragging');
                    }
                } else {
                    selectedItem = null;
                    draggingItem = null;
                }
                updatePropertiesPanel(); 
            }
            redrawCanvas();
        });
        canvas.addEventListener('mouseup', () => { /* ... (same as V5.1) ... */
            if (draggingItem) {
                draggingItem = null; 
                canvas.classList.remove('dragging');
                simulateCircuit(); 
                redrawCanvas();
            }
        });
        canvas.addEventListener('dblclick', (evt) => { /* ... (same as V5.1) ... */
            const { rawX, rawY } = getMousePos(evt, false);
            const item = getClickedItem(rawX, rawY); 
            if(item && item.itemType === 'component' && selectedTool === 'select') { 
                selectedItem = item; 
                updatePropertiesPanel(); 
                if (selectedItem.type !== 'Ammeter' && selectedItem.type !== 'Voltmeter' && selectedItem.type !== 'Switch' && selectedItem.type !== 'Ground') {
                    document.getElementById('prop-value').focus();
                    document.getElementById('prop-value').select();
                }
            } else if (item && item.itemType === 'node' && selectedTool === 'select') {
                selectedItem = item;
                updatePropertiesPanel();
            }
        });

        function updateConnectedWires(movedItem) { /* ... (same as V5.1) ... */
            wires.forEach(wire => {
                let changed = false;
                if (wire.from.type === movedItem.itemType && 
                    ( (movedItem.itemType === 'node' && wire.from.id === movedItem.id) ||
                      (movedItem.itemType === 'component' && wire.from.componentId === movedItem.id) ) ) { 
                    wire.points[0] = (movedItem.itemType === 'component') ? 
                                     getAbsTerminalPos(movedItem, wire.from.terminalId) : 
                                     {x: movedItem.x, y: movedItem.y};
                    changed = true;
                }
                if (wire.to.type === movedItem.itemType && 
                    ( (movedItem.itemType === 'node' && wire.to.id === movedItem.id) ||
                      (movedItem.itemType === 'component' && wire.to.componentId === movedItem.id) ) ) { 
                    wire.points[wire.points.length - 1] = (movedItem.itemType === 'component') ?
                                                          getAbsTerminalPos(movedItem, wire.to.terminalId) :
                                                          {x: movedItem.x, y: movedItem.y};
                    changed = true;
                }

                if (changed && electrons.length > 0 && !draggingItem) {
                     initElectronsForLoop(); 
                }
            });
        }
        function deleteSelected() { /* ... (same as V5.1) ... */
            if (!selectedItem) return;
            if (selectedItem.itemType === 'component') {
                components = components.filter(c => c.id !== selectedItem.id);
                wires = wires.filter(w => !( (w.from.type === 'terminal' && w.from.componentId === selectedItem.id) ||
                                             (w.to.type === 'terminal' && w.to.componentId === selectedItem.id) ));
            } else if (selectedItem.itemType === 'node') {
                nodes = nodes.filter(n => n.id !== selectedItem.id);
                wires = wires.filter(w => !( (w.from.type === 'node' && w.from.id === selectedItem.id) ||
                                             (w.to.type === 'node' && w.to.id === selectedItem.id) ));
            }
            selectedItem = null;
            electrons = [];
            updatePropertiesPanel();
            simulateCircuit();
            redrawCanvas();
        }

        // --- Properties Panel --- (Same as V5.1)
        const propIdInput = document.getElementById('prop-id');
        const propValueInput = document.getElementById('prop-value');
        const propUnitSpan = document.getElementById('prop-unit');
        const propRotateBtn = document.getElementById('prop-rotate');
        const noSelectionText = document.getElementById('noSelectionText');
        const selectedItemPropsDiv = document.getElementById('selectedItemProps');
        const componentSpecificPropsDiv = document.getElementById('componentSpecificProps');
        const nodeSpecificPropsDiv = document.getElementById('nodeSpecificProps');
        const switchSpecificPropsDiv = document.getElementById('switchSpecificProps');
        const propSwitchToggleBtn = document.getElementById('prop-switch-toggle');
        const meterSpecificPropsDiv = document.getElementById('meterSpecificProps');
        const meterReadingCode = document.getElementById('meter-reading');

        function updatePropertiesPanel() {
            if (selectedItem) {
                noSelectionText.style.display = 'none';
                selectedItemPropsDiv.style.display = 'block';
                propIdInput.value = selectedItem.id;

                componentSpecificPropsDiv.style.display = 'none';
                nodeSpecificPropsDiv.style.display = 'none';
                switchSpecificPropsDiv.style.display = 'none';
                meterSpecificPropsDiv.style.display = 'none';


                if (selectedItem.itemType === 'component') {
                    componentSpecificPropsDiv.style.display = 'block';
                    propValueInput.value = selectedItem.value;
                    propUnitSpan.textContent = selectedItem.spec.unit;
                    propValueInput.disabled = selectedItem.type === 'Ground' || selectedItem.type === 'Switch' || selectedItem.type === 'Ammeter' || selectedItem.type === 'Voltmeter';
                    propRotateBtn.style.display = 'block';

                    if (selectedItem.type === 'Switch') {
                        switchSpecificPropsDiv.style.display = 'block';
                        propSwitchToggleBtn.textContent = selectedItem.state.isOpen ? 'Close Switch' : 'Open Switch';
                        propSwitchToggleBtn.classList.toggle('toggle-active', !selectedItem.state.isOpen);

                    }
                    if (selectedItem.type === 'Ammeter' || selectedItem.type === 'Voltmeter') {
                        meterSpecificPropsDiv.style.display = 'block';
                        meterReadingCode.textContent = `${formatValue(selectedItem.state.reading, selectedItem.spec.unit)}${selectedItem.spec.unit}`;
                    }

                } else if (selectedItem.itemType === 'node') {
                    nodeSpecificPropsDiv.style.display = 'block';
                }
            } else {
                noSelectionText.style.display = 'block';
                selectedItemPropsDiv.style.display = 'none';
            }
        }
        propValueInput.addEventListener('change', (evt) => { 
            if (selectedItem && selectedItem.itemType === 'component') {
                const val = parseFloat(evt.target.value);
                if (!isNaN(val)) {
                    selectedItem.value = val; 
                    simulateCircuit(); 
                    redrawCanvas();
                }
            }
        });
        propRotateBtn.addEventListener('click', () => { 
            if (selectedItem && selectedItem.itemType === 'component') {
                selectedItem.rotation = (selectedItem.rotation + 90) % 360;
                updateConnectedWires(selectedItem); 
                simulateCircuit(); 
                redrawCanvas();
            }
        });
        propSwitchToggleBtn.addEventListener('click', () => { 
            if (selectedItem && selectedItem.type === 'Switch') {
                selectedItem.state.isOpen = !selectedItem.state.isOpen;
                updatePropertiesPanel(); 
                simulateCircuit();
                redrawCanvas();
            }
        });

        function formatValue(value, unit) { /* ... (same as V5.1) ... */ 
            if (value === undefined || value === null || isNaN(value)) return "N/A";
            if (unit === 'F') {
                if (Math.abs(value) >= 1e-3 && Math.abs(value) < 1) return (value * 1e3).toPrecision(3) + 'm'; 
                if (Math.abs(value) >= 1e-6 && Math.abs(value) < 1e-3) return (value * 1e6).toPrecision(3) + 'μ'; 
                if (Math.abs(value) >= 1e-9 && Math.abs(value) < 1e-6) return (value * 1e9).toPrecision(3) + 'n'; 
                if (Math.abs(value) >= 1e-12 && Math.abs(value) < 1e-9) return (value * 1e12).toPrecision(3) + 'p'; 
            } else if (unit === 'Ω') {
                if (value >= 1e6) return (value / 1e6).toPrecision(3) + 'M'; 
                if (value >= 1e3) return (value / 1e3).toPrecision(3) + 'k'; 
            } else if (unit === 'A') {
                 if (Math.abs(value) < 1e-6 && value !== 0) return (value * 1e9).toPrecision(3) + 'n';
                 if (Math.abs(value) < 1e-3 && value !== 0) return (value * 1e6).toPrecision(3) + 'μ';
                 if (Math.abs(value) < 1 && value !== 0) return (value * 1e3).toPrecision(3) + 'm';
            } else if (unit === 'V') {
                 if (Math.abs(value) < 1e-3 && value !== 0) return (value * 1e6).toPrecision(3) + 'μ';
                 if (Math.abs(value) < 1 && value !== 0) return (value * 1e3).toPrecision(3) + 'm';
            }
            if (value === 0) return "0.00";
            if (typeof value === 'number' && Number.isInteger(value) && Math.abs(value) < 10000 && Math.abs(value) > 0.001 ) return value.toFixed(2); 
            if (typeof value === 'number') return value.toPrecision(3); 
            return "Err"; 
        }


        // --- Keyboard Shortcuts --- 
        document.addEventListener('keydown', (evt) => {
            if (document.activeElement === propValueInput || document.activeElement.tagName === 'INPUT') return; 

            switch(evt.key.toLowerCase()) {
                case 'v': setActiveTool('select'); break;
                case 'w': setActiveTool('wire'); break;
                case 'j': setActiveTool('Node'); break; 
                case 'r': 
                    if (selectedItem && selectedItem.itemType === 'component') { 
                        selectedItem.rotation = (selectedItem.rotation + 90) % 360;
                        updateConnectedWires(selectedItem);
                        simulateCircuit();
                        redrawCanvas();
                    }
                    break;
                case 'delete': case 'backspace':
                    deleteSelected();
                    break;
                case 'escape':
                    if (wiringState.active) {
                        wiringState.active = false; wiringState.points = [];
                        redrawCanvas();
                    } else if (selectedTool !== 'select') {
                        setActiveTool('select');
                    } else {
                        selectedItem = null; draggingItem = null;
                        updatePropertiesPanel(); redrawCanvas();
                    }
                    break;
            }
        });

        // --- MNA Simulation Logic ---
        const simStatusDisplay = document.getElementById('sim-status');
        const nodeVoltagesDisplay = document.getElementById('node-voltages-display');
        const componentCurrentsVoltagesDisplay = document.getElementById('component-currents-voltages'); 
        const mnaDebugG = document.getElementById('mna-debug-g');
        const mnaDebugZ = document.getElementById('mna-debug-z');
        const mnaDebugX = document.getElementById('mna-debug-x');

        function getActualItemById(id) { 
            let item = components.find(c => c.id === id);
            if (item) return item;
            item = nodes.find(n => n.id === id);
            return item; // Returns the direct reference
         }
        
        function buildMNASystem() {
            let mnaNodes = {}; // Will map 'circuitNodeId' -> mnaMatrixIndex
            let mnaNodeKeyToCircuitNodeId = {}; // mnaMatrixIndex -> 'circuitNodeId' for display
            let nextMnaIndex = 0; 
            
            function getOrAssignMnaIndex(circuitNodeId) {
                if (!mnaNodes.hasOwnProperty(circuitNodeId)) {
                    mnaNodes[circuitNodeId] = nextMnaIndex;
                    mnaNodeKeyToCircuitNodeId[nextMnaIndex] = circuitNodeId;
                    nextMnaIndex++;
                }
                return mnaNodes[circuitNodeId];
            }

            // Assign ground node (MNA index 0)
            getOrAssignMnaIndex(GROUND_NODE_ID); // Ensure ground is always node 0

            let voltageSourceCount = 0;
            let componentConnectivity = []; // { compRef, term1NodeKey, term2NodeKey, vsBranchIdx }

            // Pass 1: Assign initial MNA indices to all explicit nodes and ground component terminals
            nodes.forEach(node => getOrAssignMnaIndex(node.id));
            components.forEach(comp => {
                if (comp.type === 'Ground') {
                    const groundTermKey = `term-${comp.id}-${comp.spec.terminals[0].id}`;
                    mnaNodes[groundTermKey] = mnaNodes[GROUND_NODE_ID]; // Map ground comp terminal to MNA ground
                } else if (comp.type === 'VSource' || comp.type === 'Ammeter') {
                    voltageSourceCount++;
                }
            });

            // Pass 2: Merge nodes connected by wires and assign MNA indices to component terminals
            let changedInMergeLoop;
            let mergeIterations = 0;
            const MAX_MERGE_ITERATIONS = (nodes.length + components.length + wires.length) * 2 + 10; // Safety break

            do {
                changedInMergeLoop = false;
                mergeIterations++;
                if (mergeIterations > MAX_MERGE_ITERATIONS) {
                    console.error("Node merging loop exceeded max iterations. Aborting MNA build.");
                    simStatusDisplay.textContent = "Error: Node merging loop timeout.";
                    return null;
                }

                // Assign indices to all terminals first, creating temp nodes if not yet connected
                components.forEach(comp => {
                    if (comp.type === 'Ground') return;
                    comp.spec.terminals.forEach(term => {
                        const termKey = `term-${comp.id}-${term.id}`;
                        getOrAssignMnaIndex(termKey); // Ensure every terminal has an initial MNA index
                    });
                });

                // Merge MNA indices for connected items
                wires.forEach(wire => {
                    let key1, key2;
                    if (wire.from.type === 'node') key1 = wire.from.id;
                    else key1 = `term-${wire.from.componentId}-${wire.from.terminalId}`;
                    
                    if (wire.to.type === 'node') key2 = wire.to.id;
                    else key2 = `term-${wire.to.componentId}-${wire.to.terminalId}`;

                    // Ensure both ends have an MNA index assigned (should have been by previous step)
                    const idx1 = getOrAssignMnaIndex(key1);
                    const idx2 = getOrAssignMnaIndex(key2);

                    if (idx1 !== idx2) {
                        // Merge: point all nodes with higher index to the lower index
                        const minIdx = Math.min(idx1, idx2);
                        const maxIdx = Math.max(idx1, idx2);
                        for (const key in mnaNodes) {
                            if (mnaNodes[key] === maxIdx) {
                                mnaNodes[key] = minIdx;
                                changedInMergeLoop = true;
                            }
                        }
                    }
                });
            } while (changedInMergeLoop);
            
            // Pass 3: Re-index to make MNA indices dense (0, 1, 2...)
            const uniqueIndices = [...new Set(Object.values(mnaNodes))].sort((a, b) => a - b);
            const reIndexMap = {};
            let finalMnaNodeCount = 0;
            uniqueIndices.forEach(oldIdx => {
                reIndexMap[oldIdx] = finalMnaNodeCount++;
            });
            
            const finalMnaNodes = {};
            mnaNodeKeyToCircuitNodeId = {}; // Reset and rebuild for final indices
            Object.keys(mnaNodes).forEach(key => {
                finalMnaNodes[key] = reIndexMap[mnaNodes[key]];
                if (!mnaNodeKeyToCircuitNodeId[finalMnaNodes[key]] || key.startsWith('n')) { // Prefer explicit node IDs for display
                     mnaNodeKeyToCircuitNodeId[finalMnaNodes[key]] = key;
                }
            });
            // console.log("Final MNA Node Map:", finalMnaNodes);
            // console.log("Final MNA Index to Circuit Node ID:", mnaNodeKeyToCircuitNodeId);


            const numActualNodes = finalMnaNodeCount -1; // Number of non-ground MNA nodes for matrix
            const matrixSize = numActualNodes + voltageSourceCount;
            if (matrixSize === 0) {
                simStatusDisplay.textContent = "Circuit is effectively empty for MNA (0x0 matrix).";
                return null;
            }
            
            let G = Array(matrixSize).fill(null).map(() => Array(matrixSize).fill(0));
            let z = Array(matrixSize).fill(0);
            let currentVsBranch = numActualNodes; // Start branch indices after node voltage unknowns

            components.forEach(comp => {
                if (comp.type === 'Ground') return;

                const term1Spec = comp.spec.terminals[0];
                const term2Spec = comp.spec.terminals.length > 1 ? comp.spec.terminals[1] : null;

                const n1Key = `term-${comp.id}-${term1Spec.id}`;
                let n1MatrixIdx = finalMnaNodes.hasOwnProperty(n1Key) ? finalMnaNodes[n1Key] : -1;
                
                let n2MatrixIdx = -1;
                let n2Key = null;
                if (term2Spec) {
                    n2Key = `term-${comp.id}-${term2Spec.id}`;
                    n2MatrixIdx = finalMnaNodes.hasOwnProperty(n2Key) ? finalMnaNodes[n2Key] : -1;
                }
                
                // Adjust for G matrix: MNA index 0 (ground) is not a row/col. Others are idx-1.
                const g_n1 = n1MatrixIdx > 0 ? n1MatrixIdx - 1 : -1; 
                const g_n2 = n2MatrixIdx > 0 ? n2MatrixIdx - 1 : -1;

                let info = {compRef: comp, n1Key, n2Key, n1MatrixIdx, n2MatrixIdx, g_n1, g_n2, vsBranchIdx: -1};

                if (comp.type === 'Resistor') {
                    const R = comp.value;
                    if (R === 0) { console.warn(`Resistor ${comp.id} has 0 Ohms, treating as short.`); return; } // Ideal wire, problematic
                    const conductance = 1 / R;
                    if (g_n1 !== -1) G[g_n1][g_n1] += conductance;
                    if (g_n2 !== -1) G[g_n2][g_n2] += conductance;
                    if (g_n1 !== -1 && g_n2 !== -1) {
                        G[g_n1][g_n2] -= conductance;
                        G[g_n2][g_n1] -= conductance;
                    }
                } else if (comp.type === 'VSource' || comp.type === 'Ammeter') {
                    const branchIdx = currentVsBranch++; // This is the actual index in G and z for the branch equation
                    info.vsBranchIdx = branchIdx;
                    const voltage = (comp.type === 'VSource') ? comp.value : 0; 

                    if (g_n1 !== -1) { G[branchIdx][g_n1] = 1;  G[g_n1][branchIdx] = 1;  }
                    if (g_n2 !== -1) { G[branchIdx][g_n2] = -1; G[g_n2][branchIdx] = -1; } 
                    // If one terminal is ground, the 1 or -1 is applied based on which terminal it is.
                    // Example: n1 is not ground, n2 is ground. Voltage source + at n1, - at n2 (ground).
                    // G[branchIdx][g_n1] = 1; z[branchIdx] = voltage;
                    // G[g_n1][branchIdx] = 1; 
                    // If n1 is ground, n2 is not ground. Voltage source + at n1(ground), - at n2.
                    // G[branchIdx][g_n2] = -1; z[branchIdx] = voltage; (careful with sign, z = Vp - Vn)
                    // For MNA:  Vp - Vn = Vs. If p is n1, n is n2:
                    // Stamp for Vp: G[branchIdx][g_n1] = 1 (if n1 not ground)
                    // Stamp for Vn: G[branchIdx][g_n2] = -1 (if n2 not ground)
                    // If n1 is ground: z[branchIdx] needs -Vn. G[branchIdx][g_n2] = -1. z[branchIdx] = -comp.value (if n1 is +ve term)
                    // If n2 is ground: z[branchIdx] needs Vp.  G[branchIdx][g_n1] = 1. z[branchIdx] = comp.value (if n1 is +ve term)
                    // Let's use the standard form: (Voltage at positive terminal) - (Voltage at negative terminal) = SourceVoltage
                    // Positive terminal is term1Spec (n1), negative is term2Spec (n2)
                    // So, z[branchIdx] = comp.value (or 0 for ammeter)
                    z[branchIdx] = voltage;

                } else if (comp.type === 'Switch') {
                    if (!comp.state.isOpen) { 
                        const R_closed = 0.001; 
                        const conductance = 1 / R_closed;
                        if (g_n1 !== -1) G[g_n1][g_n1] += conductance;
                        if (g_n2 !== -1) G[g_n2][g_n2] += conductance;
                        if (g_n1 !== -1 && g_n2 !== -1) {
                            G[g_n1][g_n2] -= conductance;
                            G[g_n2][g_n1] -= conductance;
                        }
                    } 
                } 
                componentConnectivity.push(info);
            });
            
            return { G, z, numActualNodes, voltageSourceCount, finalMnaNodes, componentConnectivity, matrixSize, mnaNodeKeyToCircuitNodeId };
        }


        function simulateCircuit() {
            components.forEach(c => { 
                c.voltageDrop = 0; 
                if (c.type === 'LED') c.brightness = 0; 
                if (c.type === 'Ammeter' || c.type === 'Voltmeter') c.state.reading = 0;
            });
            // Electron animation is disabled for MNA for now
            electrons = []; 
            componentPositions.pathSegments = [];

            simStatusDisplay.textContent = "Building MNA system...";
            redrawCanvas(); // Show status immediately

            // Use setTimeout to allow UI to update before potentially long MNA build
            setTimeout(() => {
                const mnaSystem = buildMNASystem();
                if (!mnaSystem) {
                    // simStatusDisplay might have been set by buildMNASystem on error
                    if (simStatusDisplay.textContent === "Building MNA system...") { // If no specific error was set
                         simStatusDisplay.textContent = "Failed to build MNA system.";
                    }
                    nodeVoltagesDisplay.innerHTML = ""; componentCurrentsVoltagesDisplay.innerHTML = "";
                    mnaDebugG.textContent = "G: Build Failed"; mnaDebugZ.textContent = "z: Build Failed"; mnaDebugX.textContent = "x: Build Failed";
                    redrawCanvas(); updatePropertiesPanel(); 
                    return;
                }

                mnaDebugG.textContent = "G Matrix (" + mnaSystem.matrixSize + "x" + mnaSystem.matrixSize + "):\n" + mnaSystem.G.map(row => row.map(v => v.toFixed(3)).join('\t')).join('\n');
                mnaDebugZ.textContent = "z Vector (" + mnaSystem.matrixSize + "x1):\n" + mnaSystem.z.map(v => v.toFixed(3)).join('\n');

                if (mnaSystem.matrixSize === 0) {
                    simStatusDisplay.textContent = "Circuit is empty or trivial (0x0 MNA matrix).";
                    nodeVoltagesDisplay.innerHTML = ""; componentCurrentsVoltagesDisplay.innerHTML = "";
                     mnaDebugX.textContent = "x: N/A (0x0 system)";
                    redrawCanvas(); updatePropertiesPanel(); return;
                }


                simStatusDisplay.textContent = "Solving MNA system...";
                redrawCanvas(); // Update UI

                setTimeout(() => { // Another timeout for the solve step
                    const solution = solveLinearSystem(mnaSystem.G, mnaSystem.z);
                    
                    if (!solution) {
                        simStatusDisplay.textContent = "MNA Solve Failed (Singular Matrix or error).";
                        mnaDebugX.textContent = "x: Solve Failed";
                        console.error("MNA Solve Failed. G:", mnaSystem.G, "z:", mnaSystem.z);
                        redrawCanvas(); updatePropertiesPanel(); return;
                    }
                    mnaDebugX.textContent = "x Solution (Node Voltages & VSource Currents):\n" + solution.map(v => v.toFixed(3)).join('\n');

                    simStatusDisplay.textContent = "MNA Solved. Processing results...";
                    nodeVoltagesDisplay.innerHTML = "<h4>Node Voltages (Rel. to Gnd):</h4>";
                    
                    const finalNodeVoltages = {}; // Stores final MNA_index -> voltage
                    for (let i = 0; i < mnaSystem.numActualNodes; i++) { // Voltages for non-ground MNA nodes
                        const mnaMatrixNodeIndex = i + 1; // MNA index (1-based for non-ground)
                        const circuitNodeId = mnaSystem.mnaNodeKeyToCircuitNodeId[mnaMatrixNodeIndex] || `InternalMNA_${mnaMatrixNodeIndex}`;
                        const voltage = solution[i];
                        finalNodeVoltages[mnaMatrixNodeIndex] = voltage;
                        nodeVoltagesDisplay.innerHTML += `<p>${circuitNodeId}: ${formatValue(voltage, "V")}V</p>`;
                    }
                    finalNodeVoltages[0] = 0; // Ground MNA index 0 has 0V


                    componentCurrentsVoltagesDisplay.innerHTML = "<h4>Component Details:</h4>";
                    mnaSystem.componentConnectivity.forEach(info => {
                        const comp = info.compRef;
                        let v1 = finalNodeVoltages[info.n1MatrixIdx] !== undefined ? finalNodeVoltages[info.n1MatrixIdx] : 0; // Default to 0 if somehow undefined (e.g. ground)
                        let v2 = finalNodeVoltages[info.n2MatrixIdx] !== undefined ? finalNodeVoltages[info.n2MatrixIdx] : 0;
                        
                        comp.voltageDrop = v1 - v2; 
                        let current = 0; // Through the component, from n1 to n2

                        if (comp.type === 'Resistor') {
                            current = comp.value > 0 ? comp.voltageDrop / comp.value : (comp.voltageDrop === 0 ? 0 : (comp.voltageDrop > 0 ? Infinity : -Infinity));
                        } else if (comp.type === 'VSource' || comp.type === 'Ammeter') {
                            current = solution[info.vsBranchIdx]; 
                            // MNA current for VSource is often defined as flowing from + to - THROUGH THE SOURCE.
                            // If n1 is positive terminal, current calculated is I_n1.
                            // We want current flowing FROM n1 TO n2 through the component.
                            // The sign from MNA solution for branch current needs careful interpretation.
                            // If G[branchIdx][g_n1] was 1 and G[branchIdx][g_n2] was -1, then solution[branchIdx] is current from n1 to n2.
                            if (info.g_n1 === -1 && info.g_n2 !== -1) current = -current; // if n1 was ground and n2 was negative terminal of source
                            
                            if (comp.type === 'Ammeter') comp.state.reading = current;
                        } else if (comp.type === 'LED') {
                            const Vf = comp.value;
                            const R_on = comp.spec.seriesResistance || 10; // Small assumed ON resistance for LED
                            if (comp.voltageDrop > Vf) { 
                                current = (comp.voltageDrop - Vf) / R_on; 
                                comp.brightness = Math.min(1, Math.abs(current) / 0.020);
                                comp.voltageDrop = Vf + current * R_on; // More accurate Vdrop
                            } else {
                                current = 0; comp.brightness = 0; comp.voltageDrop = comp.voltageDrop; // It sees the voltage, but no current flows
                            }
                        } else if (comp.type === 'Switch') {
                            if (!comp.state.isOpen) { 
                                current = comp.voltageDrop / 0.001; 
                            } else { current = 0; }
                        } else if (comp.type === 'Capacitor') {
                            current = 0; 
                        }

                        comp.current = current; // Store current for potential electron animation

                        let details = `${comp.id} (${comp.type}): V=${formatValue(comp.voltageDrop, "V")}V`;
                        if (comp.type !== 'VSource' && comp.type !== 'Voltmeter' && comp.type !== 'Capacitor' && !(comp.type === 'Switch' && comp.state.isOpen)) {
                            details += `, I=${formatValue(current, "A")}A`;
                        }
                        if (comp.type === 'LED') details += (comp.brightness > 0 ? ' (ON)' : ' (OFF)');
                        componentCurrentsVoltagesDisplay.innerHTML += `<p>${details}</p>`;
                    });
                    
                    components.filter(c => c.type === 'Voltmeter').forEach(vm => {
                        const termPInfo = mnaSystem.componentConnectivity.find(info => info.compRef.id === vm.id);
                        if (termPInfo) {
                            let vP = finalNodeVoltages[termPInfo.n1MatrixIdx] !== undefined ? finalNodeVoltages[termPInfo.n1MatrixIdx] : 0;
                            let vN = finalNodeVoltages[termPInfo.n2MatrixIdx] !== undefined ? finalNodeVoltages[termPInfo.n2MatrixIdx] : 0;
                            vm.state.reading = vP - vN;
                        } else {
                            vm.state.reading = NaN; // Cannot determine
                        }
                        let vmDetailsEntry = Array.from(componentCurrentsVoltagesDisplay.getElementsByTagName('p')).find(p => p.textContent.startsWith(vm.id));
                        if (vmDetailsEntry) vmDetailsEntry.textContent = `${vm.id} (V): Reading=${formatValue(vm.state.reading,"V")}V`; // Update existing if any
                        else componentCurrentsVoltagesDisplay.innerHTML += `<p>${vm.id} (V): Reading=${formatValue(vm.state.reading,"V")}V</p>`;
                    });

                    simStatusDisplay.textContent = "MNA Solved.";
                    redrawCanvas();
                    updatePropertiesPanel(); 
                }, 0); // End of solve timeout
            }, 0); // End of build timeout
        }


        const componentPositions = { pathSegments: [] }; 
        function initElectronsForLoop(num=30) { 
            electrons.length = 0;
            // Electron animation with MNA is complex. Needs to consider current magnitudes and directions on each wire.
            // For now, we'll skip trying to rebuild the complex electron pathfinding from the series solver.
        }
        function updateElectronsAnim(deltaTime, circuitCurrentVal) { 
            if (electrons.length > 0) { electrons = []; redrawCanvas(); } // Clear if any old ones
            return;
        }
        let lastTime = 0;
        function animationLoop(timestamp) { 
            const deltaTime = timestamp - lastTime;
            lastTime = timestamp;
            updateElectronsAnim(deltaTime || 16, 0); 
            redrawCanvas(); 
            requestAnimationFrame(animationLoop);
        }

        // --- Initial Setup ---
        setActiveTool('select');
        updatePropertiesPanel();
        redrawCanvas();
        animationLoop(0);

    </script>
</body>
</html>
