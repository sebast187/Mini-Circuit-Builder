<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Mini Circuit Builder V2.1 (Fixed Sim)</title>
    <style>
        :root {
            --sim-bg-color: #f0f4f8; /* Light bluish gray - paper-like */
            --sim-panel-bg: #ffffff; /* White for panels */
            --sim-toolbar-bg: #e9edf1;
            --sim-accent-color: #ff6b6b; /* Coral/Red for errors, some highlights */
            --sim-highlight-color: #4ecdc4; /* Teal for selection, success */
            --sim-interactive-color: #45a0fc; /* Bright Blue for interactive elements */
            --sim-text-color: #2c3e50; /* Dark blue/gray for text */
            --sim-text-muted-color: #7f8c8d; /* Muted gray */
            --sim-border-color: #ccd1d9;
            --wire-color: #3498db; /* Blue for wires */
            --wire-pending-color: #9b59b6; /* Purple for pending wire */
            --component-stroke-color: #34495e;
            --terminal-color: #e74c3c; /* Red for terminals */
            --terminal-hover-color: #f1c40f; /* Yellow for terminal hover */
            --electron-color: #f39c12; /* Orange for electrons */
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background-color: var(--sim-bg-color);
            color: var(--sim-text-color);
            margin: 0;
            padding: 0;
            display: flex;
            flex-direction: column;
            align-items: center;
            min-height: 100vh;
            overflow-x: hidden;
        }

        .main-container {
            display: flex;
            width: 95%;
            max-width: 1400px;
            margin-top: 20px;
            gap: 20px;
        }

        .toolbar {
            background-color: var(--sim-toolbar-bg);
            padding: 15px;
            border-radius: 8px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
            display: flex;
            flex-direction: column;
            gap: 10px;
            align-items: center;
            height: fit-content;
            min-width: 120px;
        }

        .toolbar button {
            background-color: var(--sim-interactive-color);
            color: white;
            border: none;
            padding: 10px 12px;
            border-radius: 6px;
            cursor: pointer;
            font-size: 0.9em;
            transition: background-color 0.2s ease;
            width: 100%;
            text-align: center;
        }
        .toolbar button.active, .toolbar button:hover {
            background-color: var(--sim-highlight-color);
        }
        .toolbar button.tool-active { /* Specifically for active tool selection */
             background-color: var(--sim-accent-color);
             color: white;
        }
        .toolbar h3 {
            margin: 0 0 10px 0;
            font-size: 1.1em;
            color: var(--sim-text-color);
        }

        .canvas-container {
            flex-grow: 1;
            display: flex;
            flex-direction: column;
            align-items: center;
        }

        #circuitCanvas {
            border: 2px solid var(--sim-border-color);
            background-color: var(--sim-panel-bg); /* Canvas background */
            border-radius: 8px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.05);
            cursor: crosshair; /* Default cursor for canvas */
        }
        #circuitCanvas.dragging {
            cursor: grabbing;
        }
        #circuitCanvas.selectable {
            cursor: pointer;
        }


        .properties-panel, .simulation-output {
            background-color: var(--sim-panel-bg);
            padding: 15px;
            border-radius: 8px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
            width: 250px;
            min-width: 250px; /* Ensure it doesn't shrink too much */
            height: fit-content;
        }
        .properties-panel h3, .simulation-output h3 {
            margin: 0 0 15px 0;
            font-size: 1.1em;
            color: var(--sim-text-color);
            border-bottom: 1px solid var(--sim-border-color);
            padding-bottom: 8px;
        }
        .properties-panel label {
            display: block;
            margin: 10px 0 5px 0;
            font-size: 0.9em;
            color: var(--sim-text-muted-color);
        }
        .properties-panel input[type="number"],
        .properties-panel input[type="text"] {
            width: calc(100% - 22px); /* Adjust for padding */
            padding: 8px 10px;
            border: 1px solid var(--sim-border-color);
            border-radius: 4px;
            font-size: 0.9em;
            background-color: var(--sim-bg-color);
            color: var(--sim-text-color);
            box-sizing: border-box;
        }
        .properties-panel p {
            font-size: 0.9em;
            color: var(--sim-text-muted-color);
        }
         .properties-panel button {
            background-color: var(--sim-interactive-color);
            color: white;
            border: none;
            padding: 8px 10px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 0.9em;
            margin-top: 10px;
            width: 100%;
        }
        .properties-panel button:hover {
            background-color: var(--sim-highlight-color);
        }

        .simulation-output p {
            font-size: 0.9em;
            margin: 8px 0;
        }
        .simulation-output code {
            font-family: 'Courier New', Courier, monospace;
            background-color: var(--sim-toolbar-bg);
            padding: 2px 5px;
            border-radius: 3px;
            color: var(--sim-accent-color);
        }

        .info-bar {
            margin-top: 10px;
            padding: 10px;
            background-color: var(--sim-toolbar-bg);
            border-radius: 6px;
            font-size: 0.9em;
            text-align: center;
            width: calc(100% - 20px); /* Match canvas container width */
        }
    </style>
</head>
<body>
    <div class="main-container">
        <div class="toolbar">
            <h3>Tools</h3>
            <button id="tool-select" title="Select/Move Tool (V)">Select (V)</button>
            <button id="tool-wire" title="Wire Tool (W)">Wire (W)</button>
            <h3>Components</h3>
            <button id="tool-vsource" data-component="VSource">Voltage Src</button>
            <button id="tool-resistor" data-component="Resistor">Resistor</button>
            <button id="tool-led" data-component="LED">LED</button>
            <button id="tool-gnd" data-component="Ground">Ground</button>
             <h3>Actions</h3>
            <button id="action-delete" title="Delete Selected (Del/Backspace)">Delete</button>
            <button id="action-clear" title="Clear Canvas">Clear All</button>
        </div>

        <div class="canvas-container">
            <canvas id="circuitCanvas" width="800" height="550"></canvas>
            <div class="info-bar" id="infoBar">Select a tool or component to start.</div>
        </div>

        <div class="side-panel">
            <div class="properties-panel" id="propertiesPanel">
                <h3>Properties</h3>
                <p id="noSelectionText">No component selected.</p>
                <div id="selectedComponentProps" style="display:none;">
                    <label for="prop-id">ID:</label>
                    <input type="text" id="prop-id" readonly>
                    <label for="prop-value">Value:</label>
                    <input type="number" id="prop-value" step="any">
                    <span id="prop-unit"></span>
                    <button id="prop-rotate">Rotate (90°)</button>
                </div>
            </div>
            <div class="simulation-output" style="margin-top:20px;">
                <h3>Simulation (Series Loop)</h3>
                <p>Total Current: <code id="sim-current">N/A</code></p>
                <p>Status: <code id="sim-status">Build a series loop.</code></p>
                <div id="component-voltages"></div>
            </div>
        </div>
    </div>

    <script>
        const canvas = document.getElementById('circuitCanvas');
        const ctx = canvas.getContext('2d');
        const infoBar = document.getElementById('infoBar');

        // --- State Variables ---
        let components = [];
        let wires = [];
        let nextComponentId = 1;
        let selectedTool = 'select'; 
        let selectedComponent = null;
        let hoveredTerminal = null;
        let wiringState = { active: false, startComponentId: null, startTerminalId: null, points: [], currentEndPoint: {x:0, y:0} };
        let draggingComponent = null;
        let dragStartOffset = { x: 0, y: 0};
        const gridSize = 20;
        const terminalRadius = 6;

        let electrons = [];
        const electronSpeedFactor = 0.5;

        // --- Component Definitions & Drawing ---
        const componentSpecs = {
            VSource: { width: 60, height: 60, color: '#f1c40f', 
                       terminals: [{ x: 0, y: -30, id: 'p' }, { x: 0, y: 30, id: 'n' }], 
                       defaultValue: 9, unit: 'V', label: 'V' },
            Resistor: { width: 80, height: 30, color: '#bdc3c7', 
                        terminals: [{ x: -40, y: 0, id: 't1' }, { x: 40, y: 0, id: 't2' }], 
                        defaultValue: 100, unit: 'Ω', label: 'R' },
            LED: { width: 50, height: 50, color: '#e74c3c', 
                   terminals: [{ x: -25, y: 0, id: 'a' }, { x: 25, y: 0, id: 'k' }], 
                   defaultValue: 2, unit: 'Vf', label: 'LED' },
            Ground: { width: 40, height: 40, color: '#2ecc71', 
                      terminals: [{ x: 0, y: -20, id: 'gnd' }], 
                      defaultValue: 0, unit: '', label: 'GND' }
        };

        function drawVSource(comp, spec) { 
            ctx.strokeStyle = 'var(--component-stroke-color)'; ctx.lineWidth = 2;
            ctx.fillStyle = spec.color;
            ctx.beginPath();
            ctx.arc(0, 0, spec.width / 2 * 0.8, 0, Math.PI * 2);
            ctx.fill(); ctx.stroke();
            ctx.fillStyle = 'var(--component-stroke-color)'; ctx.font = '16px Arial'; ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillText('+', 0, -spec.height / 4.5);
            ctx.fillText('-', 0, spec.height / 4.5);
            ctx.save();
            ctx.resetTransform(); 
            ctx.translate(comp.x, comp.y); 
            ctx.fillStyle = 'var(--component-stroke-color)'; ctx.font = '12px Arial'; ctx.textAlign = 'center';
            ctx.fillText(`${comp.value}${spec.unit}`, 0, spec.height/2 + 15);
            ctx.restore(); 
        }
        function drawResistor(comp, spec) {
            ctx.strokeStyle = 'var(--component-stroke-color)'; ctx.lineWidth = 2;
            ctx.fillStyle = spec.color;
            ctx.fillRect(-spec.width/2 + 10, -spec.height/2, spec.width - 20, spec.height);
            ctx.strokeRect(-spec.width/2 + 10, -spec.height/2, spec.width - 20, spec.height);
            ctx.beginPath(); 
            ctx.moveTo(-spec.width/2, 0); ctx.lineTo(-spec.width/2+10, 0);
            ctx.moveTo(spec.width/2-10, 0); ctx.lineTo(spec.width/2, 0);
            ctx.stroke();
            
            ctx.save(); ctx.resetTransform(); ctx.translate(comp.x, comp.y);
            ctx.fillStyle = 'var(--component-stroke-color)'; ctx.font = '12px Arial'; ctx.textAlign = 'center';
            ctx.fillText(`${comp.value}${spec.unit}`, 0, spec.height/2 + 15);
            if (comp.voltageDrop) {
                 ctx.fillStyle = 'var(--sim-interactive-color)';
                 const angle = comp.rotation % 180;
                 const yOffset = (angle === 0) ? -spec.height/2 - 8 : spec.width/2 + 8;
                 const xOffset = (angle === 90) ? -spec.height/2 -15 : 0;
                 ctx.fillText(`${comp.voltageDrop.toFixed(2)}V`, xOffset, yOffset);
            }
            ctx.restore();
        }
        function drawLED(comp, spec) {
            ctx.strokeStyle = 'var(--component-stroke-color)'; ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.moveTo(-spec.width/2 + 5, -spec.height/3); 
            ctx.lineTo(-spec.width/2 + 5, spec.height/3);
            ctx.lineTo(0, 0); 
            ctx.closePath();
            
            let ledColor = 'rgba(100,100,100,0.5)'; 
            if (comp.brightness > 0) ledColor = `rgba(255, 0, 0, ${0.2 + comp.brightness * 0.8})`;
            ctx.fillStyle = ledColor;
            ctx.fill(); ctx.stroke();
            ctx.beginPath();
            ctx.moveTo(spec.width/2 - 10, -spec.height/3);
            ctx.lineTo(spec.width/2 - 10, spec.height/3);
            ctx.stroke();
            ctx.beginPath();
            ctx.moveTo(-spec.width/2, 0); ctx.lineTo(-spec.width/2+5, 0);
            ctx.moveTo(spec.width/2-10, 0); ctx.lineTo(spec.width/2, 0);
            ctx.stroke();

            ctx.save(); ctx.resetTransform(); ctx.translate(comp.x, comp.y);
            ctx.fillStyle = 'var(--component-stroke-color)'; ctx.font = '12px Arial'; ctx.textAlign = 'center';
            ctx.fillText(`${spec.label} (Vf:${comp.value}V)`, 0, spec.height/2 + 15);
             if (comp.voltageDrop) {
                 ctx.fillStyle = 'var(--sim-interactive-color)';
                 const angle = comp.rotation % 180;
                 const yOffset = (angle === 0) ? -spec.height/2 - 8 : spec.width/2 + 8;
                 const xOffset = (angle === 90) ? -spec.height/2 -15 : 0;
                 ctx.fillText(`${comp.voltageDrop.toFixed(2)}V`, xOffset, yOffset);
            }
            ctx.restore();
        }
        function drawGround(comp, spec) {
            ctx.strokeStyle = 'var(--component-stroke-color)'; ctx.lineWidth = 2;
            ctx.fillStyle = spec.color;
            ctx.beginPath();
            ctx.moveTo(0, -spec.height/2); 
            ctx.lineTo(0, 0); 
            ctx.moveTo(-spec.width/2 + 5, 0); ctx.lineTo(spec.width/2 - 5, 0); 
            ctx.moveTo(-spec.width/2 + 10, spec.height/4); ctx.lineTo(spec.width/2 - 10, spec.height/4);
            ctx.moveTo(-spec.width/2 + 15, spec.height/2); ctx.lineTo(spec.width/2 - 15, spec.height/2); 
            ctx.stroke();
            
            ctx.save(); ctx.resetTransform(); ctx.translate(comp.x, comp.y);
            ctx.fillStyle = 'var(--component-stroke-color)'; ctx.font = '12px Arial'; ctx.textAlign = 'center';
            ctx.fillText(spec.label, 0, spec.height/2 + 10);
            ctx.restore();
        }

        const drawFunctions = { VSource: drawVSource, Resistor: drawResistor, LED: drawLED, Ground: drawGround };

        function getAbsTerminalPos(component, terminalId) {
            const termSpec = component.spec.terminals.find(t => t.id === terminalId);
            if (!termSpec) return { x: component.x, y: component.y }; 

            const angleRad = component.rotation * Math.PI / 180;
            const cosA = Math.cos(angleRad);
            const sinA = Math.sin(angleRad);

            const rotatedX = termSpec.x * cosA - termSpec.y * sinA;
            const rotatedY = termSpec.x * sinA + termSpec.y * cosA;

            return { x: component.x + rotatedX, y: component.y + rotatedY };
        }
        
        function drawComponent(comp) {
            ctx.save();
            ctx.translate(comp.x, comp.y); 
            ctx.rotate(comp.rotation * Math.PI / 180); 

            drawFunctions[comp.type](comp, comp.spec); 
            
            comp.spec.terminals.forEach(term => {
                ctx.beginPath();
                ctx.arc(term.x, term.y, terminalRadius, 0, Math.PI * 2);
                const isHovered = hoveredTerminal && hoveredTerminal.componentId === comp.id && hoveredTerminal.terminalId === term.id;
                ctx.fillStyle = isHovered ? 'var(--terminal-hover-color)' : 'var(--terminal-color)';
                ctx.fill();
            });
            ctx.restore(); 

            if (selectedComponent === comp) {
                ctx.strokeStyle = 'var(--sim-highlight-color)';
                ctx.lineWidth = 2;
                const w = comp.spec.width; const h = comp.spec.height;
                const angle = comp.rotation % 180; 
                const displayW = (angle === 0) ? w : h;
                const displayH = (angle === 0) ? h : w;
                ctx.strokeRect(comp.x - displayW/2 - 5, comp.y - displayH/2 - 5, displayW + 10, displayH + 10);
            }
        }

        function drawWires() {
            wires.forEach(wire => {
                if (wire.points.length < 2) return;
                ctx.beginPath();
                ctx.moveTo(wire.points[0].x, wire.points[0].y);
                for (let i = 1; i < wire.points.length; i++) {
                    ctx.lineTo(wire.points[i].x, wire.points[i].y);
                }
                ctx.strokeStyle = 'var(--wire-color)';
                ctx.lineWidth = 3;
                ctx.stroke();
            });

            if (wiringState.active && wiringState.points.length > 0) {
                ctx.beginPath();
                const lastPoint = wiringState.points[wiringState.points.length - 1];
                ctx.moveTo(lastPoint.x, lastPoint.y);
                ctx.lineTo(wiringState.currentEndPoint.x, wiringState.currentEndPoint.y);
                ctx.strokeStyle = 'var(--wire-pending-color)';
                ctx.lineWidth = 2;
                ctx.setLineDash([5, 5]);
                ctx.stroke();
                ctx.setLineDash([]);
            }
        }
        
        function drawElectrons() {
            electrons.forEach(e => {
                ctx.beginPath();
                ctx.arc(e.x, e.y, 3, 0, Math.PI * 2);
                ctx.fillStyle = 'var(--electron-color)';
                ctx.fill();
            });
        }

        function redrawCanvas() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            components.forEach(drawComponent); 
            drawWires();
            drawElectrons();
        }

        // --- UI & Interaction ---
        function updateToolbarButtons() {
            document.querySelectorAll('.toolbar button[data-component], #tool-select, #tool-wire').forEach(btn => {
                btn.classList.remove('tool-active');
                if ((btn.dataset.component && btn.dataset.component === selectedTool) || (btn.id === `tool-${selectedTool}`)) {
                    btn.classList.add('tool-active');
                }
            });
            let toolInfo = `Tool: ${selectedTool}.`;
            if (selectedTool === 'wire') toolInfo += " Click terminal or empty space for joints.";
            else if (componentSpecs[selectedTool]) toolInfo += " Click canvas to place.";
            else toolInfo += " Click component to select/drag.";
            infoBar.textContent = toolInfo;
        }

        function setActiveTool(toolName) {
            selectedTool = toolName;
            selectedComponent = null; 
            updatePropertiesPanel();
            if (wiringState.active) { 
                wiringState.active = false;
                wiringState.points = [];
            }
            updateToolbarButtons();
        }

        document.getElementById('tool-select').addEventListener('click', () => setActiveTool('select'));
        document.getElementById('tool-wire').addEventListener('click', () => setActiveTool('wire'));
        document.querySelectorAll('.toolbar button[data-component]').forEach(btn => {
            btn.addEventListener('click', () => setActiveTool(btn.dataset.component));
        });
        document.getElementById('action-delete').addEventListener('click', deleteSelected);
        document.getElementById('action-clear').addEventListener('click', () => {
            components = []; wires = []; electrons = []; nextComponentId = 1;
            selectedComponent = null; wiringState.active = false; wiringState.points = [];
            updatePropertiesPanel(); simulateCircuit(); redrawCanvas();
        });


        function getMousePos(evt, doSnap = true) {
            const rect = canvas.getBoundingClientRect();
            const rawX = evt.clientX - rect.left;
            const rawY = evt.clientY - rect.top;
            if (doSnap) {
                return {
                    x: Math.round(rawX / gridSize) * gridSize,
                    y: Math.round(rawY / gridSize) * gridSize,
                    rawX: rawX, rawY: rawY
                };
            }
            return { x: rawX, y: rawY, rawX: rawX, rawY: rawY }; 
        }

        function getHoveredTerminal(rawX, rawY) {
            for (const comp of components) {
                for (const term of comp.spec.terminals) {
                    const absPos = getAbsTerminalPos(comp, term.id);
                    const dist = Math.sqrt((rawX - absPos.x)**2 + (rawY - absPos.y)**2);
                    if (dist < terminalRadius + 3) { 
                        return { componentId: comp.id, terminalId: term.id, absPos: absPos };
                    }
                }
            }
            return null;
        }
        
        function getClickedComponent(rawX, rawY) {
             for (let i = components.length - 1; i >= 0; i--) {
                const comp = components[i];
                const angleRad = -comp.rotation * Math.PI / 180; 
                const cosA = Math.cos(angleRad);
                const sinA = Math.sin(angleRad);

                const localX = rawX - comp.x;
                const localY = rawY - comp.y;

                const unrotX = localX * cosA - localY * sinA;
                const unrotY = localX * sinA + localY * cosA;

                if (unrotX >= -comp.spec.width/2 && unrotX <= comp.spec.width/2 &&
                    unrotY >= -comp.spec.height/2 && unrotY <= comp.spec.height/2) {
                    return comp;
                }
            }
            return null;
        }

        canvas.addEventListener('mousemove', (evt) => {
            const { rawX, rawY } = getMousePos(evt, false); 
            hoveredTerminal = getHoveredTerminal(rawX, rawY);
            
            canvas.classList.remove('selectable', 'dragging');
            if (selectedTool === 'select' && (getClickedComponent(rawX, rawY) || hoveredTerminal)) {
                 canvas.classList.add('selectable');
            }
            if (draggingComponent) {
                 canvas.classList.add('dragging');
            }


            if (wiringState.active) {
                wiringState.currentEndPoint = {x: rawX, y: rawY};
            } else if (draggingComponent) {
                const mousePos = getMousePos(evt); 
                draggingComponent.x = mousePos.x - dragStartOffset.x;
                draggingComponent.y = mousePos.y - dragStartOffset.y;
                updateConnectedWires(draggingComponent);
            }
            redrawCanvas();
        });

        canvas.addEventListener('mousedown', (evt) => {
            const { x, y, rawX, rawY } = getMousePos(evt); 
            const clickedTermObj = getHoveredTerminal(rawX, rawY);

            if (evt.button !== 0) return;

            if (selectedTool === 'wire') {
                if (!wiringState.active) { 
                    if (clickedTermObj) {
                        wiringState.active = true;
                        wiringState.startComponentId = clickedTermObj.componentId;
                        wiringState.startTerminalId = clickedTermObj.terminalId;
                        wiringState.points = [clickedTermObj.absPos];
                        wiringState.currentEndPoint = {x: rawX, y: rawY};
                    }
                } else { 
                    if (clickedTermObj) { 
                        const startComp = findComponentById(wiringState.startComponentId);
                        const endComp = findComponentById(clickedTermObj.componentId);
                        if (startComp && endComp && 
                           !(startComp.id === endComp.id && wiringState.startTerminalId === clickedTermObj.terminalId)) {
                            wiringState.points.push(clickedTermObj.absPos);
                            wires.push({
                                id: `w${wires.length + 1}`,
                                fromComponentId: wiringState.startComponentId,
                                fromTerminalId: wiringState.startTerminalId,
                                toComponentId: clickedTermObj.componentId,
                                toTerminalId: clickedTermObj.terminalId,
                                points: [...wiringState.points] 
                            });
                            wiringState.active = false; wiringState.points = [];
                            simulateCircuit();
                        } else { 
                           console.log("Invalid wire end.");
                           wiringState.active = false; wiringState.points = []; 
                        }
                    } else { 
                        wiringState.points.push({x: x, y: y}); 
                        wiringState.currentEndPoint = {x: rawX, y: rawY};
                    }
                }
            } else if (componentSpecs[selectedTool]) { 
                const spec = componentSpecs[selectedTool];
                const newComp = {
                    id: `${selectedTool.charAt(0)}${nextComponentId++}`,
                    type: selectedTool,
                    x: x, y: y, 
                    rotation: 0,
                    value: spec.defaultValue,
                    spec: spec,
                    brightness: 0 
                };
                components.push(newComp);
                selectedComponent = newComp; 
                updatePropertiesPanel();
                setActiveTool('select'); 
            } else if (selectedTool === 'select') {
                const compUnderMouse = getClickedComponent(rawX, rawY);
                if (compUnderMouse) {
                    selectedComponent = compUnderMouse;
                    draggingComponent = compUnderMouse;
                    dragStartOffset.x = x - compUnderMouse.x;
                    dragStartOffset.y = y - compUnderMouse.y;
                    canvas.classList.add('dragging');

                } else {
                    selectedComponent = null;
                    draggingComponent = null;
                }
                updatePropertiesPanel();
            }
            redrawCanvas();
        });

        canvas.addEventListener('mouseup', () => {
            if (draggingComponent) {
                draggingComponent = null; 
                canvas.classList.remove('dragging');
                simulateCircuit(); 
                redrawCanvas();
            }
        });
        
        canvas.addEventListener('dblclick', (evt) => {
            const { rawX, rawY } = getMousePos(evt, false);
            const comp = getClickedComponent(rawX, rawY);
            if(comp && selectedTool === 'select') {
                selectedComponent = comp;
                updatePropertiesPanel(); 
                document.getElementById('prop-value').focus();
                document.getElementById('prop-value').select();
            }
        });

        function updateConnectedWires(movedComponent) {
            wires.forEach(wire => {
                let changed = false;
                if (wire.fromComponentId === movedComponent.id) {
                    wire.points[0] = getAbsTerminalPos(movedComponent, wire.fromTerminalId);
                    changed = true;
                }
                if (wire.toComponentId === movedComponent.id) {
                    wire.points[wire.points.length - 1] = getAbsTerminalPos(movedComponent, wire.toTerminalId);
                    changed = true;
                }
                if (changed && electrons.length > 0 && !draggingComponent) { // Re-init electrons only if wire changed and not actively dragging
                     initElectronsForLoop();
                }
            });
        }
        
        function deleteSelected() {
            if (!selectedComponent) return;
            components = components.filter(c => c.id !== selectedComponent.id);
            wires = wires.filter(w => w.fromComponentId !== selectedComponent.id && w.toComponentId !== selectedComponent.id);
            selectedComponent = null;
            electrons = [];
            updatePropertiesPanel();
            simulateCircuit();
            redrawCanvas();
        }

        // --- Properties Panel ---
        const propIdInput = document.getElementById('prop-id');
        const propValueInput = document.getElementById('prop-value');
        const propUnitSpan = document.getElementById('prop-unit');
        const propRotateBtn = document.getElementById('prop-rotate');
        const noSelectionText = document.getElementById('noSelectionText');
        const selectedComponentPropsDiv = document.getElementById('selectedComponentProps');

        function updatePropertiesPanel() {
            if (selectedComponent) {
                noSelectionText.style.display = 'none';
                selectedComponentPropsDiv.style.display = 'block';
                propIdInput.value = selectedComponent.id;
                propValueInput.value = selectedComponent.value;
                propUnitSpan.textContent = selectedComponent.spec.unit;
                propValueInput.disabled = selectedComponent.type === 'Ground';
            } else {
                noSelectionText.style.display = 'block';
                selectedComponentPropsDiv.style.display = 'none';
            }
        }
        propValueInput.addEventListener('change', (evt) => {
            if (selectedComponent) {
                const val = parseFloat(evt.target.value);
                if (!isNaN(val)) {
                    selectedComponent.value = val;
                    simulateCircuit(); 
                    redrawCanvas();
                }
            }
        });
        propRotateBtn.addEventListener('click', () => {
            if (selectedComponent) {
                selectedComponent.rotation = (selectedComponent.rotation + 90) % 360;
                updateConnectedWires(selectedComponent); 
                simulateCircuit(); 
                redrawCanvas();
            }
        });


        // --- Keyboard Shortcuts ---
        document.addEventListener('keydown', (evt) => {
            if (document.activeElement === propValueInput || document.activeElement.tagName === 'INPUT') return; 

            switch(evt.key.toLowerCase()) {
                case 'v': setActiveTool('select'); break;
                case 'w': setActiveTool('wire'); break;
                case 'delete': case 'backspace':
                    deleteSelected();
                    break;
                case 'escape':
                    if (wiringState.active) {
                        wiringState.active = false; wiringState.points = [];
                        redrawCanvas();
                    } else if (selectedTool !== 'select') {
                        setActiveTool('select');
                    } else {
                        selectedComponent = null; draggingComponent = null;
                        updatePropertiesPanel(); redrawCanvas();
                    }
                    break;
            }
        });

        // --- Simulation Logic (VERY Simplified: Single Series Loop) ---
        const simCurrentDisplay = document.getElementById('sim-current');
        const simStatusDisplay = document.getElementById('sim-status');
        const componentVoltagesDiv = document.getElementById('component-voltages');

        function findComponentById(id) { return components.find(c => c.id === id); }

        function simulateCircuit() {
            components.forEach(c => { c.voltageDrop = null; if (c.type === 'LED') c.brightness = 0; });
            electrons = [];
            componentPositions.pathSegments = [];

            const sources = components.filter(c => c.type === 'VSource');
            if (sources.length !== 1) {
                simStatusDisplay.textContent = sources.length === 0 ? "No voltage source." : "Multi-source not supported.";
                simCurrentDisplay.textContent = "N/A"; componentVoltagesDiv.innerHTML = "";
                redrawCanvas(); return;
            }
            const source = sources[0];
            
            let pathComponentsData = []; 
            let visitedWires = new Set();
            let totalResistance = 0;
            let totalLedVf = 0;
            
            let currentSimComp = source;
            let currentSimTerminalId = 'p'; 

            const loopPathForElectrons = []; 

            for (let i = 0; i < (components.length + wires.length) * 2 + 5; i++) { 
                const isRevisitingNonSource = pathComponentsData.some(
                    pd => pd.comp.id === currentSimComp.id && pd.entryTerminalId === currentSimTerminalId
                );

                if (isRevisitingNonSource && !(currentSimComp.id === source.id && currentSimTerminalId === 'n')) {
                     simStatusDisplay.textContent = "Error: Premature loop or short.";
                     console.log("Premature loop detected at:", currentSimComp.id, "terminal:", currentSimTerminalId, "Path Data:", JSON.parse(JSON.stringify(pathComponentsData)));
                     redrawCanvas(); return;
                }
                
                const currentCompDataEntry = { comp: {id: currentSimComp.id, type: currentSimComp.type, value: currentSimComp.value}, // Store minimal data
                                               entryTerminalId: currentSimTerminalId, 
                                               exitTerminalId: null, 
                                               actualCompObject: currentSimComp };
                
                pathComponentsData.push(currentCompDataEntry); // Add current component *before* processing its "through-path"

                if (currentSimComp.type === 'Resistor') totalResistance += currentSimComp.value;
                if (currentSimComp.type === 'LED') totalLedVf += currentSimComp.value;

                const outWire = wires.find(w => !visitedWires.has(w.id) && 
                                               ((w.fromComponentId === currentSimComp.id && w.fromTerminalId === currentSimTerminalId) ||
                                                (w.toComponentId === currentSimComp.id && w.toTerminalId === currentSimTerminalId)));
                
                if (!outWire) { 
                    simStatusDisplay.textContent = "Circuit not closed (wire missing from " + currentSimComp.id + ":" + currentSimTerminalId + ")."; 
                    redrawCanvas(); return; 
                }
                visitedWires.add(outWire.id);

                let nextCompId, nextTerminalOnNextComp, wirePointsToAdd;
                const compIsFrom = outWire.fromComponentId === currentSimComp.id && outWire.fromTerminalId === currentSimTerminalId;

                if (compIsFrom) {
                    nextCompId = outWire.toComponentId;
                    nextTerminalOnNextComp = outWire.toTerminalId;
                    wirePointsToAdd = [...outWire.points];
                } else {
                    nextCompId = outWire.fromComponentId;
                    nextTerminalOnNextComp = outWire.fromTerminalId;
                    wirePointsToAdd = [...outWire.points].reverse();
                }
                
                for(let j=0; j < wirePointsToAdd.length - 1; j++) {
                    loopPathForElectrons.push({start: wirePointsToAdd[j], end: wirePointsToAdd[j+1], wire: true});
                }

                const nextSimCompCandidate = findComponentById(nextCompId);
                if (!nextSimCompCandidate) { simStatusDisplay.textContent = "Error: Broken connection (component " + nextCompId + " not found)."; redrawCanvas(); return; }
                
                // Update currentSimComp and currentSimTerminalId to the *next* component and its *entry* terminal
                currentSimComp = nextSimCompCandidate;
                currentSimTerminalId = nextTerminalOnNextComp; 

                // Now, for this new currentSimComp, determine its exit terminal for the electron path and for the next iteration
                if (currentSimComp.type !== 'Ground' && !(currentSimComp.id === source.id && currentSimTerminalId === 'n')) {
                    const entryTermPos = getAbsTerminalPos(currentSimComp, currentSimTerminalId); // Entry point for electron path
                    const exitTermSpec = currentSimComp.spec.terminals.find(t => t.id !== currentSimTerminalId);

                    if (exitTermSpec) {
                        const exitTermPos = getAbsTerminalPos(currentSimComp, exitTermSpec.id);
                        loopPathForElectrons.push({start: entryTermPos, end: exitTermPos, component: currentSimComp});
                        
                        // Update the exitTerminalId for the *current* component's entry in pathComponentsData
                        // The last entry in pathComponentsData should be the one we just moved TO.
                        const lastPathEntry = pathComponentsData[pathComponentsData.length - 1];
                        if (lastPathEntry && lastPathEntry.comp.id === currentSimComp.id) {
                             lastPathEntry.exitTerminalId = exitTermSpec.id;
                        }

                        currentSimTerminalId = exitTermSpec.id; // Update for the next wire search FROM this component
                    } else if (currentSimComp.spec.terminals.length > 1) { 
                         simStatusDisplay.textContent = "Error: Comp path def (" + currentSimComp.id + ")."; redrawCanvas(); return;
                    }
                }


                if (currentSimComp.id === source.id && currentSimTerminalId === 'n') {
                    // Ensure the source itself is in the path if loop completes there
                    let sourceEndEntry = pathComponentsData.find(pd => pd.comp.id === source.id && pd.entryTerminalId === 'n');
                    if (!sourceEndEntry) {
                         pathComponentsData.push({ comp: {id: source.id, type: source.type, value: source.value}, entryTerminalId: 'n', exitTerminalId: null, actualCompObject: source });
                    }
                    break; 
                }
                if (currentSimComp.type === 'Ground') {
                    let groundEntry = pathComponentsData.find(pd => pd.comp.id === currentSimComp.id && pd.entryTerminalId === currentSimTerminalId);
                     if (!groundEntry) {
                        pathComponentsData.push({ comp: {id: currentSimComp.id, type: currentSimComp.type, value: currentSimComp.value}, entryTerminalId: currentSimTerminalId, exitTerminalId: null, actualCompObject: currentSimComp });
                     }
                    break;
                }
            }
            
            if (!((currentSimComp.id === source.id && currentSimTerminalId === 'n') || currentSimComp.type === 'Ground')) {
                simStatusDisplay.textContent = "Not a closed series loop to source neg/ground.";
                simCurrentDisplay.textContent = "N/A"; componentVoltagesDiv.innerHTML = "";
                redrawCanvas(); return;
            }

            let circuitCurrent = 0;
            if (source.value >= totalLedVf) { 
                if (totalResistance > 0) {
                    circuitCurrent = (source.value - totalLedVf) / totalResistance;
                } else if (source.value - totalLedVf > 0.00001) circuitCurrent = Infinity;
            }
            
            simCurrentDisplay.textContent = isFinite(circuitCurrent) ? `${(circuitCurrent * 1000).toFixed(2)} mA` : "Short Circuit!";
            simStatusDisplay.textContent = isFinite(circuitCurrent) ? "OK (Series Loop)" : "Warning!";
            componentVoltagesDiv.innerHTML = "";

            pathComponentsData.forEach(pd => {
                const comp = pd.actualCompObject;
                if (!comp) return;

                if (comp.type === 'Resistor' && isFinite(circuitCurrent)) {
                    comp.voltageDrop = circuitCurrent * comp.value;
                    componentVoltagesDiv.innerHTML += `<p>${comp.id} (R): ${comp.voltageDrop.toFixed(2)}V</p>`;
                }
                if (comp.type === 'LED') {
                    if (isFinite(circuitCurrent) && circuitCurrent > 0.0001 && source.value >= totalLedVf) {
                        comp.brightness = Math.min(1, circuitCurrent / 0.020); 
                        comp.voltageDrop = comp.value; 
                         componentVoltagesDiv.innerHTML += `<p>${comp.id} (LED): ${comp.voltageDrop.toFixed(2)}V (ON)</p>`;
                    } else {
                        comp.brightness = 0; comp.voltageDrop = 0;
                        componentVoltagesDiv.innerHTML += `<p>${comp.id} (LED): 0V (OFF)</p>`;
                    }
                }
            });

            if (isFinite(circuitCurrent) && circuitCurrent > 0.0001 && loopPathForElectrons.length > 0) {
                 componentPositions.pathSegments = loopPathForElectrons; 
                 initElectronsForLoop(Math.min(50, Math.floor(circuitCurrent * 1000 * 2))); 
            } else {
                componentPositions.pathSegments = [];
            }
            redrawCanvas();
        }

        // --- Electron Animation (adapted) ---
        const componentPositions = { pathSegments: [] }; 

        function initElectronsForLoop(num=30) {
            electrons.length = 0;
            if (!componentPositions.pathSegments || componentPositions.pathSegments.length === 0) return;

            for (let i = 0; i < num; i++) {
                const segmentIndex = Math.floor(Math.random() * componentPositions.pathSegments.length);
                const segment = componentPositions.pathSegments[segmentIndex];
                if (!segment || !segment.start || !segment.end) continue; 
                const progress = Math.random();
                
                electrons.push({
                    x: segment.start.x + (segment.end.x - segment.start.x) * progress,
                    y: segment.start.y + (segment.end.y - segment.start.y) * progress,
                    segmentIndex: segmentIndex,
                    progress: progress,
                });
            }
        }

        function updateElectronsAnim(deltaTime, circuitCurrentVal) {
            if (circuitCurrentVal <= 0 || !isFinite(circuitCurrentVal) || electrons.length === 0 || componentPositions.pathSegments.length === 0) {
                if (electrons.length > 0) { electrons = []; redrawCanvas(); } 
                return;
            }

            const speed = circuitCurrentVal * electronSpeedFactor * 1000 * (deltaTime / 16); 

            electrons.forEach(e => {
                if (e.segmentIndex >= componentPositions.pathSegments.length) { 
                     e.segmentIndex = 0; 
                }
                let currentSegment = componentPositions.pathSegments[e.segmentIndex];
                if (!currentSegment || !currentSegment.start || !currentSegment.end) { 
                     e.segmentIndex = (e.segmentIndex + 1) % componentPositions.pathSegments.length;
                     if (componentPositions.pathSegments.length > 0) currentSegment = componentPositions.pathSegments[e.segmentIndex];
                     else return; 
                }

                let segmentLength = Math.sqrt(Math.pow(currentSegment.end.x - currentSegment.start.x, 2) + Math.pow(currentSegment.end.y - currentSegment.start.y, 2));
                
                if (segmentLength < 0.01) e.progress = 1.0; 
                else e.progress += speed / segmentLength;

                while (e.progress >= 1.0 && componentPositions.pathSegments.length > 0) {
                    e.progress -= 1.0;
                    e.segmentIndex = (e.segmentIndex + 1) % componentPositions.pathSegments.length;
                    currentSegment = componentPositions.pathSegments[e.segmentIndex];
                     if (!currentSegment || !currentSegment.start || !currentSegment.end) { 
                         if (componentPositions.pathSegments.length > 0) e.segmentIndex = 0; 
                         else return; 
                     }
                    segmentLength = Math.sqrt(Math.pow(currentSegment.end.x - currentSegment.start.x, 2) + Math.pow(currentSegment.end.y - currentSegment.start.y, 2));
                    if (segmentLength < 0.01) e.progress = 1.0;
                }
                
                if (currentSegment && currentSegment.start && currentSegment.end) { 
                    e.x = currentSegment.start.x + (currentSegment.end.x - currentSegment.start.x) * e.progress;
                    e.y = currentSegment.start.y + (currentSegment.end.y - currentSegment.start.y) * e.progress;
                }
            });
        }
        
        let lastTime = 0;
        function animationLoop(timestamp) {
            const deltaTime = timestamp - lastTime;
            lastTime = timestamp;

            let currentValForAnim = 0;
            const currentText = simCurrentDisplay.textContent;
            if (currentText && currentText.includes("mA")) {
                currentValForAnim = parseFloat(currentText) / 1000; 
            }
            
            updateElectronsAnim(deltaTime || 16, currentValForAnim);
            redrawCanvas(); 
            requestAnimationFrame(animationLoop);
        }

        // --- Initial Setup ---
        setActiveTool('select');
        updatePropertiesPanel();
        redrawCanvas();
        animationLoop(0);

    </script>
</body>
</html>